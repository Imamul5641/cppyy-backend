diff --git a/src/core/base/src/TQConnection.cxx b/src/core/base/src/TQConnection.cxx
index 5a7516e0e9..eafb05410c 100644
--- a/src/core/base/src/TQConnection.cxx
+++ b/src/core/base/src/TQConnection.cxx
@@ -48,7 +48,7 @@ protected:
    CallFunc_t    *fFunc;      // CINT method invocation environment
    ClassInfo_t   *fClass;     // CINT class for fFunc
    TFunction     *fMethod;    // slot method or global function
-   Long_t         fOffset;    // offset added to object pointer
+   intptr_t       fOffset;    // offset added to object pointer
    TString        fName;      // full name of method
    Int_t          fExecuting; // true if one of this slot's ExecuteMethod methods is being called
 public:
@@ -57,7 +57,7 @@ public:
    virtual ~TQSlot();
 
    Bool_t      CheckSlot(Int_t nargs) const;
-   Long_t      GetOffset() const { return fOffset; }
+   intptr_t    GetOffset() const { return fOffset; }
    CallFunc_t *StartExecuting();
    CallFunc_t *GetFunc() const { return fFunc; }
    void        EndExecuting();
diff --git a/src/core/meta/inc/TBaseClass.h b/src/core/meta/inc/TBaseClass.h
index b8cb31cf85..151db725ff 100644
--- a/src/core/meta/inc/TBaseClass.h
+++ b/src/core/meta/inc/TBaseClass.h
@@ -32,13 +32,13 @@ class TClass;
 
 class TBaseClass : public TDictionary {
 #ifndef __CLING__
-   using AtomicInt_t = std::atomic<Int_t>;
-   static_assert(sizeof(std::atomic<Int_t>) == sizeof(Int_t),
-                 "We requiqre atomic<int> and <int> to have the same size but they are not");
+   using AtomicInt_t = std::atomic<ptrdiff_t>;
+   static_assert(sizeof(std::atomic<ptrdiff_t>) == sizeof(ptrdiff_t),
+                 "We require atomic<ptrdiff_t> and <ptrdiff_t> to have the same size but they are not");
 #else
    // std::atomic is not yet supported in the I/O, so
    // we hide them from Cling
-   using AtomicInt_t = Int_t;
+   using AtomicInt_t = ptrdiff_t;
 #endif
 
 private:
@@ -59,7 +59,7 @@ public:
    virtual void   Browse(TBrowser *b);
    const char    *GetTitle() const;
    TClass        *GetClassPointer(Bool_t load=kTRUE);
-   Int_t          GetDelta();
+   ptrdiff_t      GetDelta();
    Bool_t         IsFolder() const {return kTRUE;}
    ROOT::ESTLType IsSTLContainer();
    Long_t         Property() const;
diff --git a/src/core/meta/inc/TClass.h b/src/core/meta/inc/TClass.h
index be1c4d88b4..eb99fb131c 100644
--- a/src/core/meta/inc/TClass.h
+++ b/src/core/meta/inc/TClass.h
@@ -237,7 +237,7 @@ private:
    }
    mutable std::atomic<UChar_t> fRuntimeProperties;    //! Properties that can only be evaluated at run-time
 
-   mutable Long_t     fOffsetStreamer;  //!saved info to call Streamer
+   mutable intptr_t   fOffsetStreamer;  //!saved info to call Streamer
    Int_t              fStreamerType;    //!cached of the streaming method to use
    EState             fState;           //!Current 'state' of the class (Emulated,Interpreted,Loaded)
    mutable std::atomic<TVirtualStreamerInfo*>  fCurrentInfo;     //!cached current streamer info.
@@ -256,7 +256,7 @@ private:
    TListOfFunctions  *GetMethodList();
    TMethod           *GetClassMethod(Long_t faddr);
    TMethod           *FindClassOrBaseMethodWithId(DeclId_t faddr);
-   Int_t              GetBaseClassOffsetRecurse(const TClass *toBase);
+   ptrdiff_t          GetBaseClassOffsetRecurse(const TClass *toBase);
    void Init(const char *name, Version_t cversion, const std::type_info *info,
              TVirtualIsAProxy *isa,
              const char *dfil, const char *ifil,
@@ -358,7 +358,7 @@ public:
    void               AdoptSchemaRules( ROOT::Detail::TSchemaRuleSet *rules );
    virtual void       Browse(TBrowser *b);
    void               BuildRealData(void *pointer=0, Bool_t isTransient = kFALSE);
-   void               BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl);
+   void               BuildEmulatedRealData(const char *name, intptr_t offset, TClass *cl);
    void               CalculateStreamerOffset() const;
    Bool_t             CallShowMembers(const void* obj, TMemberInspector &insp, Bool_t isTransient = kFALSE) const;
    Bool_t             CanSplit() const;
@@ -391,7 +391,7 @@ public:
    Version_t          GetClassVersion() const { fVersionUsed = kTRUE; return fClassVersion; }
    Int_t              GetClassSize() const { return Size(); }
    TDataMember       *GetDataMember(const char *datamember) const;
-   Long_t             GetDataMemberOffset(const char *membername) const;
+   intptr_t             GetDataMemberOffset(const char *membername) const;
    const char        *GetDeclFileName() const;
    Short_t            GetDeclFileLine() const { return fDeclFileLine; }
    ROOT::DelFunc_t    GetDelete() const;
@@ -423,7 +423,7 @@ public:
    TClass            *GetActualClass(const void *object) const;
    TClass            *GetBaseClass(const char *classname);
    TClass            *GetBaseClass(const TClass *base);
-   Int_t              GetBaseClassOffset(const TClass *toBase, void *address = 0, bool isDerivedObject = true);
+   intptr_t           GetBaseClassOffset(const TClass *toBase, void *address = 0, bool isDerivedObject = true);
    TClass            *GetBaseDataMember(const char *datamember);
    ROOT::ESTLType     GetCollectionType() const;
    ROOT::DirAutoAdd_t GetDirectoryAutoAdd() const;
diff --git a/src/core/meta/inc/TDataMember.h b/src/core/meta/inc/TDataMember.h
index 220f3578d1..b8c863cc1e 100644
--- a/src/core/meta/inc/TDataMember.h
+++ b/src/core/meta/inc/TDataMember.h
@@ -39,7 +39,7 @@ private:
    TClass             *fClass;        //!pointer to the class
    TDataType          *fDataType;     //!pointer to data basic type descriptor
 
-   Long_t              fOffset;       //offset
+   intptr_t            fOffset;       //offset
    Int_t               fSTLCont;      //STL type
    Long_t              fProperty;     //Property
    Int_t               fArrayDim;     //Number of array dimensions
@@ -72,8 +72,8 @@ public:
    Int_t          GetMaxIndex(Int_t dim) const;
    TClass        *GetClass() const { return fClass; }
    TDataType     *GetDataType() const { return fDataType; } //only for basic type
-   Long_t         GetOffset() const;
-   Long_t         GetOffsetCint() const;
+   intptr_t       GetOffset() const;
+   intptr_t       GetOffsetCint() const;
    const char    *GetTypeName() const;
    const char    *GetFullTypeName() const;
    const char    *GetTrueTypeName() const;
diff --git a/src/core/meta/inc/TInterpreter.h b/src/core/meta/inc/TInterpreter.h
index b14fb6ebe0..68fc50b91c 100644
--- a/src/core/meta/inc/TInterpreter.h
+++ b/src/core/meta/inc/TInterpreter.h
@@ -385,13 +385,13 @@ public:
       CallFunc_SetArgImpl(func,args...);
    }
 
-   virtual void   CallFunc_SetFunc(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* params */, bool /* objectIsConst */, Long_t * /* Offset */) const {;}
-   virtual void   CallFunc_SetFunc(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* params */, Long_t * /* Offset */) const {;}
+   virtual void   CallFunc_SetFunc(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* params */, bool /* objectIsConst */, intptr_t * /* Offset */) const {;}
+   virtual void   CallFunc_SetFunc(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* params */, intptr_t * /* Offset */) const {;}
    virtual void   CallFunc_SetFunc(CallFunc_t * /* func */, MethodInfo_t * /* info */) const {;}
-   virtual void   CallFunc_SetFuncProto(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* proto */, Long_t * /* Offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {;}
-   virtual void   CallFunc_SetFuncProto(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* proto */, bool /* objectIsConst */, Long_t * /* Offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {;}
-   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const = 0;
-   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const = 0;
+   virtual void   CallFunc_SetFuncProto(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* proto */, intptr_t * /* Offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {;}
+   virtual void   CallFunc_SetFuncProto(CallFunc_t * /* func */, ClassInfo_t * /* info */, const char * /* method */, const char * /* proto */, bool /* objectIsConst */, intptr_t * /* Offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {;}
+   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, intptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const = 0;
+   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, intptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const = 0;
 
    virtual std::string CallFunc_GetWrapperCode(CallFunc_t *func) const = 0;
 
@@ -405,7 +405,7 @@ public:
    virtual ClassInfo_t  *ClassInfo_Factory(Bool_t /*all*/ = kTRUE) const = 0;
    virtual ClassInfo_t  *ClassInfo_Factory(ClassInfo_t * /* cl */) const = 0;
    virtual ClassInfo_t  *ClassInfo_Factory(const char * /* name */) const = 0;
-   virtual Long_t   ClassInfo_GetBaseOffset(ClassInfo_t* /* fromDerived */,
+   virtual intptr_t ClassInfo_GetBaseOffset(ClassInfo_t* /* fromDerived */,
                                             ClassInfo_t* /* toBase */, void* /* address */ = 0, bool /*isderived*/ = true) const {return 0;}
    virtual int    ClassInfo_GetMethodNArg(ClassInfo_t * /* info */, const char * /* method */,const char * /* proto */, Bool_t /* objectIsConst */ = false, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {return 0;}
    virtual Bool_t ClassInfo_HasDefaultConstructor(ClassInfo_t * /* info */) const {return 0;}
@@ -416,8 +416,8 @@ public:
    virtual Bool_t ClassInfo_IsEnum(const char * /* name */) const {return 0;}
    virtual Bool_t ClassInfo_IsLoaded(ClassInfo_t * /* info */) const {return 0;}
    virtual Bool_t ClassInfo_IsValid(ClassInfo_t * /* info */) const {return 0;}
-   virtual Bool_t ClassInfo_IsValidMethod(ClassInfo_t * /* info */, const char * /* method */,const char * /* proto */, Long_t * /* offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {return 0;}
-   virtual Bool_t ClassInfo_IsValidMethod(ClassInfo_t * /* info */, const char * /* method */,const char * /* proto */, Bool_t /* objectIsConst */, Long_t * /* offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {return 0;}
+   virtual Bool_t ClassInfo_IsValidMethod(ClassInfo_t * /* info */, const char * /* method */,const char * /* proto */, intptr_t * /* offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {return 0;}
+   virtual Bool_t ClassInfo_IsValidMethod(ClassInfo_t * /* info */, const char * /* method */,const char * /* proto */, Bool_t /* objectIsConst */, intptr_t * /* offset */, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const {return 0;}
    virtual int    ClassInfo_Next(ClassInfo_t * /* info */) const {return 0;}
    virtual void  *ClassInfo_New(ClassInfo_t * /* info */) const {return 0;}
    virtual void  *ClassInfo_New(ClassInfo_t * /* info */, int /* n */) const {return 0;}
@@ -440,7 +440,7 @@ public:
                                                    ClassInfo_t* /* base */) const {return 0;}
    virtual int    BaseClassInfo_Next(BaseClassInfo_t * /* bcinfo */) const {return 0;}
    virtual int    BaseClassInfo_Next(BaseClassInfo_t * /* bcinfo */, int  /* onlyDirect */) const {return 0;}
-   virtual Long_t BaseClassInfo_Offset(BaseClassInfo_t * /* toBaseClassInfo */, void* /* address */ = 0 /*default for non-virtual*/, bool /*isderived*/ = true /*default for non-virtual*/) const {return 0;}
+   virtual intptr_t BaseClassInfo_Offset(BaseClassInfo_t * /* toBaseClassInfo */, void* /* address */ = 0 /*default for non-virtual*/, bool /*isderived*/ = true /*default for non-virtual*/) const {return 0;}
    virtual Long_t BaseClassInfo_Property(BaseClassInfo_t * /* bcinfo */) const {return 0;}
    virtual Long_t BaseClassInfo_Tagnum(BaseClassInfo_t * /* bcinfo */) const {return 0;}
    virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t * /* bcinfo */) const = 0;
diff --git a/src/core/meta/inc/TRealData.h b/src/core/meta/inc/TRealData.h
index b53c84bf84..7c9f9b9227 100644
--- a/src/core/meta/inc/TRealData.h
+++ b/src/core/meta/inc/TRealData.h
@@ -31,7 +31,7 @@ class TRealData : public TObject {
 
 private:
    TDataMember     *fDataMember;     //pointer to data member descriptor
-   Long_t           fThisOffset;     //offset with the THIS object pointer
+   intptr_t         fThisOffset;     //offset with the THIS object pointer
    TString          fName;           //Concatenated names of this realdata
    TMemberStreamer *fStreamer;       //Object to stream the data member.
    Bool_t           fIsObject;       //true if member is an object
@@ -45,14 +45,14 @@ public:
    };
 
    TRealData();
-   TRealData(const char *name, Long_t offset, TDataMember *datamember);
+   TRealData(const char *name, intptr_t offset, TDataMember *datamember);
    virtual     ~TRealData();
 
    void                AdoptStreamer(TMemberStreamer *p);
    virtual const char *GetName() const {return fName.Data();}
    TDataMember        *GetDataMember() const {return fDataMember;}
    TMemberStreamer    *GetStreamer() const;
-   Long_t              GetThisOffset() const {return fThisOffset;}
+   intptr_t            GetThisOffset() const {return fThisOffset;}
    Bool_t              IsObject() const {return fIsObject;}
    void                SetIsObject(Bool_t isObject) {fIsObject=isObject;}
    void                WriteRealData(void *pointer, char *&buffer);
diff --git a/src/core/meta/src/TBaseClass.cxx b/src/core/meta/src/TBaseClass.cxx
index fdffc4ac76..570db574bc 100644
--- a/src/core/meta/src/TBaseClass.cxx
+++ b/src/core/meta/src/TBaseClass.cxx
@@ -72,7 +72,7 @@ TClass *TBaseClass::GetClassPointer(Bool_t load)
 ////////////////////////////////////////////////////////////////////////////////
 /// Get offset from "this" to part of base class.
 
-Int_t TBaseClass::GetDelta()
+ptrdiff_t TBaseClass::GetDelta()
 {
    // Initialized to INT_MAX to signal that it's unset; -1 is a valid value
    // meaning "cannot calculate base offset".
@@ -81,7 +81,7 @@ Int_t TBaseClass::GetDelta()
       if (Property() & kIsVirtualBase)
          fDelta = -1;
       else if (fInfo)
-         fDelta = (Int_t)gCling->BaseClassInfo_Offset(fInfo);
+         fDelta = (ptrdiff_t)gCling->BaseClassInfo_Offset(fInfo);
    }
    return fDelta;
 }
diff --git a/src/core/meta/src/TClass.cxx b/src/core/meta/src/TClass.cxx
index 4ee0e3f3e2..970bdd274d 100644
--- a/src/core/meta/src/TClass.cxx
+++ b/src/core/meta/src/TClass.cxx
@@ -1901,7 +1901,7 @@ Int_t TClass::Browse(void *obj, TBrowser *b) const
       if (!fIsOffsetStreamerSet) {
          CalculateStreamerOffset();
       }
-      TObject* realTObject = (TObject*)((size_t)obj + fOffsetStreamer);
+      TObject* realTObject = (TObject*)((intptr_t)obj + fOffsetStreamer);
       realTObject->Browse(b);
       return 1;
    } else if (actual != this) {
@@ -2024,7 +2020,7 @@ void TClass::BuildRealData(void* pointer, Bool_t isTransient)
 ////////////////////////////////////////////////////////////////////////////////
 /// Build the list of real data for an emulated class
 
-void TClass::BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl)
+void TClass::BuildEmulatedRealData(const char *name, intptr_t offset, TClass *cl)
 {
    R__LOCKGUARD(gInterpreterMutex);
 
@@ -2045,7 +2045,7 @@ void TClass::BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl)
    TStreamerElement *element;
    while ((element = (TStreamerElement*)next())) {
       Int_t etype    = element->GetType();
-      Long_t eoffset = element->GetOffset();
+      intptr_t eoffset = element->GetOffset();
       TClass *cle    = element->GetClassPointer();
       if (element->IsBase() || etype == TVirtualStreamerInfo::kBase) {
          //base class are skipped in this loop, they will be added at the end.
@@ -2081,7 +2081,7 @@ void TClass::BuildEmulatedRealData(const char *name, Long_t offset, TClass *cl)
       Int_t etype    = element->GetType();
       if (element->IsBase() || etype == TVirtualStreamerInfo::kBase) {
          //base class
-         Long_t eoffset = element->GetOffset();
+         intptr_t eoffset = element->GetOffset();
          TClass *cle    = element->GetClassPointer();
          if (cle) cle->BuildEmulatedRealData(name,offset+eoffset,cl);
       }
@@ -2541,7 +2541,7 @@ TClass *TClass::GetActualClass(const void *object) const
          if (!fIsOffsetStreamerSet) {
             CalculateStreamerOffset();
          }
-         TObject* realTObject = (TObject*)((size_t)object + fOffsetStreamer);
+         TObject* realTObject = (TObject*)((intptr_t)object + fOffsetStreamer);
 
          return realTObject->IsA();
       }
@@ -2625,7 +2625,7 @@ TClass *TClass::GetBaseClass(const TClass *cl)
 ///    because it's virtual.
 /// Takes care of multiple inheritance.
 
-Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)
+ptrdiff_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)
 {
    // check if class name itself is equal to classname
    if (cl == this) return 0;
@@ -2639,7 +2639,7 @@ Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)
          TVirtualStreamerInfo *sinfo = GetCurrentStreamerInfo();
          if (!sinfo) return -1;
          TStreamerElement *element;
-         Int_t offset = 0;
+         ptrdiff_t offset = 0;
 
          TObjArray &elems = *(sinfo->GetElements());
          Int_t size = elems.GetLast()+1;
@@ -2650,7 +2650,7 @@ Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)
                   TStreamerBase *base = (TStreamerBase*)element;
                   TClass *baseclass = base->GetClassPointer();
                   if (!baseclass) return -1;
-                  Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);
+                  ptrdiff_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);
                   if (subOffset == -2) return -2;
                   if (subOffset != -1) return offset+subOffset;
                   offset += baseclass->Size();
@@ -2658,7 +2658,7 @@ Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)
                   TStreamerSTL *base = (TStreamerSTL*)element;
                   TClass *baseclass = base->GetClassPointer();
                   if (!baseclass) return -1;
-                  Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);
+                  ptrdiff_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);
                   if (subOffset == -2) return -2;
                   if (subOffset != -1) return offset+subOffset;
                   offset += baseclass->Size();
@@ -2711,7 +2711,7 @@ Int_t TClass::GetBaseClassOffsetRecurse(const TClass *cl)
 ///  - Returns -1 in case "cl" is not a base class.
 /// Takes care of multiple inheritance.
 
-Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject)
+ptrdiff_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDerivedObject)
 {
    // Warning("GetBaseClassOffset","Requires the use of fClassInfo for %s to %s",GetName(),toBase->GetName());
 
@@ -2722,7 +2722,7 @@ Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDer
       // At least of the ClassInfo have not been loaded in memory yet and
       // since there is no virtual base class (or we don't have enough so it
       // would not make a difference) we can use the 'static' information
-      Int_t offset = GetBaseClassOffsetRecurse (toBase);
+      ptrdiff_t offset = GetBaseClassOffsetRecurse (toBase);
       if (offset != -2) {
          return offset;
       }
@@ -2736,7 +2736,7 @@ Int_t TClass::GetBaseClassOffset(const TClass *toBase, void *address, bool isDer
       return gCling->ClassInfo_GetBaseOffset(derived, base, address, isDerivedObject);
    }
    else {
-      Int_t offset = GetBaseClassOffsetRecurse (toBase);
+      ptrdiff_t offset = GetBaseClassOffsetRecurse (toBase);
       if (offset != -2) {
          return offset;
       }
@@ -3319,7 +3319,7 @@ TDataMember *TClass::GetDataMember(const char *datamember) const
 ///
 /// In case of an emulated class, the list of emulated TRealData is built
 
-Long_t TClass::GetDataMemberOffset(const char *name) const
+intptr_t TClass::GetDataMemberOffset(const char *name) const
 {
    TRealData *rd = GetRealData(name);
    if (rd) return rd->GetThisOffset();
@@ -5844,7 +5844,7 @@ Long_t TClass::Property() const
       kl->SetBit(kIsTObject);
 
       // Is it DIRECT inheritance from TObject?
-      Int_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());
+      ptrdiff_t delta = kl->GetBaseClassOffsetRecurse(TObject::Class());
       if (delta==0) kl->SetBit(kStartWithTObject);
 
       kl->fStreamerType  = kTObject;
diff --git a/src/core/meta/src/TDataMember.cxx b/src/core/meta/src/TDataMember.cxx
index 73323fc27d..82ebdb54fb 100644
--- a/src/core/meta/src/TDataMember.cxx
+++ b/src/core/meta/src/TDataMember.cxx
@@ -628,9 +628,9 @@ const char *TDataMember::GetTrueTypeName() const
 ////////////////////////////////////////////////////////////////////////////////
 /// Get offset from "this".
 
-Long_t TDataMember::GetOffset() const
+intptr_t TDataMember::GetOffset() const
 {
-   if (fOffset>=0) return fOffset;
+   if (fOffset != (intptr_t)-1) return fOffset;
 
    R__LOCKGUARD(gInterpreterMutex);
    //case of an interpreted or emulated class
@@ -647,7 +647,7 @@ Long_t TDataMember::GetOffset() const
    fClass->BuildRealData();
    TIter next(fClass->GetListOfRealData());
    TRealData *rdm;
-   Int_t offset = 0;
+   intptr_t offset = -1;
    while ((rdm = (TRealData*)next())) {
       char *rdmc = (char*)rdm->GetName();
       //next statement required in case a class and one of its parent class
@@ -677,9 +677,9 @@ Long_t TDataMember::GetOffset() const
 ////////////////////////////////////////////////////////////////////////////////
 /// Get offset from "this" using the information in CINT only.
 
-Long_t TDataMember::GetOffsetCint() const
+intptr_t TDataMember::GetOffsetCint() const
 {
-   if (fOffset>=0) return fOffset;
+   if (fOffset != (intptr_t)-1) return fOffset;
 
    R__LOCKGUARD(gInterpreterMutex);
    TDataMember *dm = const_cast<TDataMember*>(this);
@@ -751,7 +751,7 @@ int TDataMember::IsSTLContainer()
 
 Bool_t TDataMember::IsValid()
 {
-   if (fOffset >= 0) return kTRUE;
+   if (fOffset != (intptr_t)-1) return kTRUE;
 
    // Register the transaction when checking the validity of the object.
    if (!fInfo && UpdateInterpreterStateMarker()) {
diff --git a/src/core/meta/src/TMethodCall.cxx b/src/core/meta/src/TMethodCall.cxx
index e419debf8c..1d5ebe9039 100644
--- a/src/core/meta/src/TMethodCall.cxx
+++ b/src/core/meta/src/TMethodCall.cxx
@@ -317,7 +317,7 @@ void TMethodCall::InitImplementation(const char *methodname, const char *params,
    if (!scope) return;
 
    R__LOCKGUARD(gInterpreterMutex);
-   Long_t offset = fOffset;
+   intptr_t offset = fOffset;
    if (params && params[0]) {
       gCling->CallFunc_SetFunc(fFunc, scope, (char *)methodname, (char *)params, objectIsConst, &offset);
    } else if (proto && proto[0]) {
@@ -326,7 +326,7 @@ void TMethodCall::InitImplementation(const char *methodname, const char *params,
       // No parameters
       gCling->CallFunc_SetFuncProto(fFunc, scope, (char *)methodname, "", objectIsConst, &offset, mode);
    }
-   fOffset = (intptr_t)offset;
+   fOffset = offset;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/src/core/meta/src/TRealData.cxx b/src/core/meta/src/TRealData.cxx
index 6d282ab324..983608c3fd 100644
--- a/src/core/meta/src/TRealData.cxx
+++ b/src/core/meta/src/TRealData.cxx
@@ -40,7 +40,7 @@ TRealData::TRealData() : TObject(), fDataMember(0), fThisOffset(-1),
 /// Constructor to define one persistent data member.
 /// datamember is the pointer to the data member descriptor.
 
-TRealData::TRealData(const char *name, Long_t offset, TDataMember *datamember)
+TRealData::TRealData(const char *name, intptr_t offset, TDataMember *datamember)
    : TObject(), fDataMember(datamember), fThisOffset(offset), fName(name),
      fStreamer(0), fIsObject(kFALSE)
 {
diff --git a/src/core/metacling/src/TCling.cxx b/src/core/metacling/src/TCling.cxx
index cf890d63e1..9a59030df4 100644
--- a/src/core/metacling/src/TCling.cxx
+++ b/src/core/metacling/src/TCling.cxx
@@ -4492,13 +4492,13 @@ TString TCling::GetMangledName(TClass* cl, const char* method,
    R__LOCKGUARD(gInterpreterMutex);
    TClingCallFunc func(fInterpreter,*fNormalizedCtxt);
    if (cl) {
-      Long_t offset;
+      intptr_t offset;
       func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,
          &offset);
    }
    else {
       TClingClassInfo gcl(fInterpreter);
-      Long_t offset;
+      intptr_t offset;
       func.SetFunc(&gcl, method, params, &offset);
    }
    TClingMethodInfo* mi = (TClingMethodInfo*) func.FactoryMethod();
@@ -4537,13 +4537,13 @@ void* TCling::GetInterfaceMethod(TClass* cl, const char* method,
    R__LOCKGUARD(gInterpreterMutex);
    TClingCallFunc func(fInterpreter,*fNormalizedCtxt);
    if (cl) {
-      Long_t offset;
+      intptr_t offset;
       func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst,
                    &offset);
    }
    else {
       TClingClassInfo gcl(fInterpreter);
-      Long_t offset;
+      intptr_t offset;
       func.SetFunc(&gcl, method, params, &offset);
    }
    return (void*) func.InterfaceMethod();
@@ -4757,7 +4757,7 @@ void TCling::Execute(const char* function, const char* params, int* error)
       *error = TInterpreter::kNoError;
    }
    TClingClassInfo cl(fInterpreter);
-   Long_t offset = 0L;
+   intptr_t offset = 0;
    TClingCallFunc func(fInterpreter,*fNormalizedCtxt);
    func.SetFunc(&cl, function, params, &offset);
    func.Exec(0);
@@ -4785,7 +4785,7 @@ void TCling::Execute(TObject* obj, TClass* cl, const char* method,
    // 'obj' is unlikely to be the start of the object (as described by IsA()),
    // hence gInterpreter->Execute will improperly correct the offset.
    void* addr = cl->DynamicCast(TObject::Class(), obj, kFALSE);
-   Long_t offset = 0L;
+   intptr_t offset = 0;
    TClingCallFunc func(fInterpreter,*fNormalizedCtxt);
    func.SetFunc((TClingClassInfo*)cl->GetClassInfo(), method, params, objectIsConst, &offset);
    void* address = (void*)((intptr_t)addr + offset);
@@ -7461,7 +7461,7 @@ void TCling::CallFunc_SetArgs(CallFunc_t* func, const char* param) const
 
 ////////////////////////////////////////////////////////////////////////////////
 
-void TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* offset) const
+void TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, intptr_t* offset) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
    TClingClassInfo* ci = (TClingClassInfo*) info;
@@ -7470,7 +7470,7 @@ void TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* m
 
 ////////////////////////////////////////////////////////////////////////////////
 
-void TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, bool objectIsConst, Long_t* offset) const
+void TCling::CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, bool objectIsConst, intptr_t* offset) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
    TClingClassInfo* ci = (TClingClassInfo*) info;
@@ -7488,7 +7488,7 @@ void TCling::CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const
 ////////////////////////////////////////////////////////////////////////////////
 /// Interface to cling function
 
-void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
+void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, intptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
    TClingClassInfo* ci = (TClingClassInfo*) info;
@@ -7498,7 +7498,7 @@ void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const ch
 ////////////////////////////////////////////////////////////////////////////////
 /// Interface to cling function
 
-void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
+void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, intptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
    TClingClassInfo* ci = (TClingClassInfo*) info;
@@ -7508,7 +7508,7 @@ void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const ch
 ////////////////////////////////////////////////////////////////////////////////
 /// Interface to cling function
 
-void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
+void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, intptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
    TClingClassInfo* ci = (TClingClassInfo*) info;
@@ -7523,7 +7523,7 @@ void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const ch
 ////////////////////////////////////////////////////////////////////////////////
 /// Interface to cling function
 
-void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
+void TCling::CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, intptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
 {
    TClingCallFunc* f = (TClingCallFunc*) func;
    TClingClassInfo* ci = (TClingClassInfo*) info;
@@ -7710,7 +7710,7 @@ bool TCling::ClassInfo_IsValid(ClassInfo_t* cinfo) const
 
 ////////////////////////////////////////////////////////////////////////////////
 
-bool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
+bool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, intptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
 {
    TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;
    return TClinginfo->IsValidMethod(method, proto, false, offset, mode);
@@ -7718,7 +7718,7 @@ bool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, con
 
 ////////////////////////////////////////////////////////////////////////////////
 
-bool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst, Long_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
+bool TCling::ClassInfo_IsValidMethod(ClassInfo_t* cinfo, const char* method, const char* proto, Bool_t objectIsConst, intptr_t* offset, EFunctionMatchMode mode /* = kConversionMatch */) const
 {
    TClingClassInfo* TClinginfo = (TClingClassInfo*) cinfo;
    return TClinginfo->IsValidMethod(method, proto, objectIsConst, offset, mode);
@@ -7882,7 +7882,7 @@ int TCling::BaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const
 
 ////////////////////////////////////////////////////////////////////////////////
 
-Long_t TCling::BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const
+intptr_t TCling::BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const
 {
    TClingBaseClassInfo* TClinginfo = (TClingBaseClassInfo*) toBaseClassInfo;
    return TClinginfo->Offset(address, isDerivedObject);
@@ -7890,7 +7890,7 @@ Long_t TCling::BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * add
 
 ////////////////////////////////////////////////////////////////////////////////
 
-Long_t TCling::ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const
+intptr_t TCling::ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const
 {
    TClingClassInfo* TClinginfo = (TClingClassInfo*) fromDerived;
    TClingClassInfo* TClinginfoBase = (TClingClassInfo*) toBase;
diff --git a/src/core/metacling/src/TCling.h b/src/core/metacling/src/TCling.h
index 60481cc25b..48ad81004c 100644
--- a/src/core/metacling/src/TCling.h
+++ b/src/core/metacling/src/TCling.h
@@ -380,13 +380,13 @@ public: // Public Interface
    virtual void   CallFunc_SetArg(CallFunc_t* func, ULong64_t param) const;
    virtual void   CallFunc_SetArgArray(CallFunc_t* func, Long_t* paramArr, Int_t nparam) const;
    virtual void   CallFunc_SetArgs(CallFunc_t* func, const char* param) const;
-   virtual void   CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, Long_t* Offset) const;
-   virtual void   CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, bool objectIsConst, Long_t* Offset) const;
+   virtual void   CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, intptr_t* Offset) const;
+   virtual void   CallFunc_SetFunc(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* params, bool objectIsConst, intptr_t* Offset) const;
    virtual void   CallFunc_SetFunc(CallFunc_t* func, MethodInfo_t* info) const;
-   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
-   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
-   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
-   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, Long_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
+   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, intptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
+   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const char* proto, bool objectIsConst, intptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
+   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, intptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
+   virtual void   CallFunc_SetFuncProto(CallFunc_t* func, ClassInfo_t* info, const char* method, const std::vector<TypeInfo_t*> &proto, bool objectIsConst, intptr_t* Offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
 
    virtual std::string CallFunc_GetWrapperCode(CallFunc_t *func) const;
 
@@ -401,7 +401,7 @@ public: // Public Interface
    virtual ClassInfo_t*  ClassInfo_Factory(Bool_t all = kTRUE) const;
    virtual ClassInfo_t*  ClassInfo_Factory(ClassInfo_t* cl) const;
    virtual ClassInfo_t*  ClassInfo_Factory(const char* name) const;
-   virtual Long_t   ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const;
+   virtual intptr_t   ClassInfo_GetBaseOffset(ClassInfo_t* fromDerived, ClassInfo_t* toBase, void * address, bool isDerivedObject) const;
    virtual int    ClassInfo_GetMethodNArg(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst = false, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
    virtual bool   ClassInfo_HasDefaultConstructor(ClassInfo_t* info) const;
    virtual bool   ClassInfo_HasMethod(ClassInfo_t* info, const char* name) const;
@@ -411,8 +411,8 @@ public: // Public Interface
    virtual bool   ClassInfo_IsEnum(const char* name) const;
    virtual bool   ClassInfo_IsLoaded(ClassInfo_t* info) const;
    virtual bool   ClassInfo_IsValid(ClassInfo_t* info) const;
-   virtual bool   ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Long_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const;
-   virtual bool   ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst, Long_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const;
+   virtual bool   ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, intptr_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const;
+   virtual bool   ClassInfo_IsValidMethod(ClassInfo_t* info, const char* method, const char* proto, Bool_t objectIsConst, intptr_t* offset, ROOT::EFunctionMatchMode /* mode */ = ROOT::kConversionMatch) const;
    virtual int    ClassInfo_Next(ClassInfo_t* info) const;
    virtual void*  ClassInfo_New(ClassInfo_t* info) const;
    virtual void*  ClassInfo_New(ClassInfo_t* info, int n) const;
@@ -434,7 +434,7 @@ public: // Public Interface
                                                    ClassInfo_t* base) const;
    virtual int    BaseClassInfo_Next(BaseClassInfo_t* bcinfo) const;
    virtual int    BaseClassInfo_Next(BaseClassInfo_t* bcinfo, int onlyDirect) const;
-   virtual Long_t BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const;
+   virtual intptr_t BaseClassInfo_Offset(BaseClassInfo_t* toBaseClassInfo, void * address, bool isDerivedObject) const;
    virtual Long_t BaseClassInfo_Property(BaseClassInfo_t* bcinfo) const;
    virtual Long_t BaseClassInfo_Tagnum(BaseClassInfo_t* bcinfo) const;
    virtual ClassInfo_t*BaseClassInfo_ClassInfo(BaseClassInfo_t * /* bcinfo */) const;
diff --git a/src/core/metacling/src/TClingBaseClassInfo.cxx b/src/core/metacling/src/TClingBaseClassInfo.cxx
index 1bba752656..388b705735 100644
--- a/src/core/metacling/src/TClingBaseClassInfo.cxx
+++ b/src/core/metacling/src/TClingBaseClassInfo.cxx
@@ -57,7 +57,7 @@ using namespace std;
 TClingBaseClassInfo::TClingBaseClassInfo(cling::Interpreter* interp,
                                          TClingClassInfo* ci)
    : fInterp(interp), fClassInfo(0), fFirstTime(true), fDescend(false),
-     fDecl(0), fIter(0), fBaseInfo(0), fOffset(0L), fClassInfoOwnership(true)
+     fDecl(0), fIter(0), fBaseInfo(0), fOffset(0), fClassInfoOwnership(true)
 {
    // Constructs a base class iterator on ci; ci == 0 means global scope (which
    // is meaningless). The derived class info passed in as ci is copied.
@@ -88,7 +88,7 @@ TClingBaseClassInfo::TClingBaseClassInfo(cling::Interpreter* interp,
                                          TClingClassInfo* derived,
                                          TClingClassInfo* base)
    : fInterp(interp), fClassInfo(0), fFirstTime(true), fDescend(false),
-     fDecl(0), fIter(0), fBaseInfo(0), fOffset(0L), fClassInfoOwnership(false)
+     fDecl(0), fIter(0), fBaseInfo(0), fOffset(0), fClassInfoOwnership(false)
 {
    // Constructs a single base class base (no iterator) of derived; derived must be != 0.
    // The derived class info is referenced during the lifetime of the TClingBaseClassInfo.
@@ -287,9 +287,9 @@ int TClingBaseClassInfo::InternalNext(int onlyDirect)
          const clang::RecordDecl *RD = llvm::dyn_cast<clang::RecordDecl>(fDecl);
          const clang::ASTRecordLayout &Layout = Context.getASTRecordLayout(RD);
          int64_t offset = Layout.getBaseClassOffset(Base).getQuantity();
-         fOffset += static_cast<long>(offset);
+         fOffset += static_cast<ptrdiff_t>(offset);
          fIterStack.push_back(std::make_pair(std::make_pair(fDecl, fIter),
-                                             static_cast<long>(offset)));
+                                             static_cast<ptrdiff_t>(offset)));
          fDecl = Base;
          fIter = Base->bases_begin();
       }
diff --git a/src/core/metacling/src/TClingBaseClassInfo.h b/src/core/metacling/src/TClingBaseClassInfo.h
index a36ff14748..d626cfdbe2 100644
--- a/src/core/metacling/src/TClingBaseClassInfo.h
+++ b/src/core/metacling/src/TClingBaseClassInfo.h
@@ -51,7 +51,7 @@ private:
    clang::CXXRecordDecl::base_class_const_iterator fIter; // Current iterator.
    TClingClassInfo              *fBaseInfo; // Base class our iterator is currently pointing at, we own.
    std::vector<std::pair<std::pair<const clang::Decl*, clang::CXXRecordDecl::base_class_const_iterator>, long> > fIterStack; // Iterator stack.
-   long                          fOffset; // Offset of the current base, fDecl, in the most-derived class.
+   ptrdiff_t                     fOffset; // Offset of the current base, fDecl, in the most-derived class.
    bool                          fClassInfoOwnership; // We created the fClassInfo and we need to delete it in the constructor.
 
 public:
diff --git a/src/core/metacling/src/TClingCallFunc.cxx b/src/core/metacling/src/TClingCallFunc.cxx
index 1bae809e7c..9bc534b3cd 100644
--- a/src/core/metacling/src/TClingCallFunc.cxx
+++ b/src/core/metacling/src/TClingCallFunc.cxx
@@ -2335,13 +2335,13 @@ void TClingCallFunc::SetArgs(const char *params)
 }
 
 void TClingCallFunc::SetFunc(const TClingClassInfo *info, const char *method, const char *arglist,
-                             long *poffset)
+                             intptr_t *poffset)
 {
    SetFunc(info, method, arglist, false, poffset);
 }
 
 void TClingCallFunc::SetFunc(const TClingClassInfo *info, const char *method, const char *arglist,
-                             bool objectIsConst, long *poffset)
+                             bool objectIsConst, intptr_t *poffset)
 {
    Init(std::unique_ptr<TClingMethodInfo>(new TClingMethodInfo(fInterp)));
    if (poffset) {
@@ -2378,14 +2378,14 @@ void TClingCallFunc::SetFunc(const TClingMethodInfo *info)
 }
 
 void TClingCallFunc::SetFuncProto(const TClingClassInfo *info, const char *method,
-                                  const char *proto, long *poffset,
+                                  const char *proto, intptr_t *poffset,
                                   EFunctionMatchMode mode/*=kConversionMatch*/)
 {
    SetFuncProto(info, method, proto, false, poffset, mode);
 }
 
 void TClingCallFunc::SetFuncProto(const TClingClassInfo *info, const char *method,
-                                  const char *proto, bool objectIsConst, long *poffset,
+                                  const char *proto, bool objectIsConst, intptr_t *poffset,
                                   EFunctionMatchMode mode/*=kConversionMatch*/)
 {
    Init(std::unique_ptr<TClingMethodInfo>(new TClingMethodInfo(fInterp)));
@@ -2406,7 +2406,7 @@ void TClingCallFunc::SetFuncProto(const TClingClassInfo *info, const char *metho
 }
 
 void TClingCallFunc::SetFuncProto(const TClingClassInfo *info, const char *method,
-                                  const llvm::SmallVectorImpl<clang::QualType> &proto, long *poffset,
+                                  const llvm::SmallVectorImpl<clang::QualType> &proto, intptr_t *poffset,
                                   EFunctionMatchMode mode/*=kConversionMatch*/)
 {
    SetFuncProto(info, method, proto, false, poffset, mode);
@@ -2414,7 +2414,7 @@ void TClingCallFunc::SetFuncProto(const TClingClassInfo *info, const char *metho
 
 void TClingCallFunc::SetFuncProto(const TClingClassInfo *info, const char *method,
                                   const llvm::SmallVectorImpl<clang::QualType> &proto,
-                                  bool objectIsConst, long *poffset,
+                                  bool objectIsConst, intptr_t *poffset,
                                   EFunctionMatchMode mode/*=kConversionMatch*/)
 {
    Init(std::unique_ptr<TClingMethodInfo>(new TClingMethodInfo(fInterp)));
diff --git a/src/core/metacling/src/TClingCallFunc.h b/src/core/metacling/src/TClingCallFunc.h
index f4caff56ed..5aaee1bcda 100644
--- a/src/core/metacling/src/TClingCallFunc.h
+++ b/src/core/metacling/src/TClingCallFunc.h
@@ -220,23 +220,23 @@ public:
    void SetArgArray(long* argArr, int narg);
    void SetArgs(const char* args);
    void SetFunc(const TClingClassInfo* info, const char* method,
-                const char* arglist, long* poffset);
+                const char* arglist, intptr_t* poffset);
    void SetFunc(const TClingClassInfo* info, const char* method,
-                const char* arglist, bool objectIsConst, long* poffset);
+                const char* arglist, bool objectIsConst, intptr_t* poffset);
    void SetFunc(const TClingMethodInfo* info);
    void SetFuncProto(const TClingClassInfo* info, const char* method,
-                     const char* proto, long* poffset,
+                     const char* proto, intptr_t* poffset,
                      ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);
    void SetFuncProto(const TClingClassInfo* info, const char* method,
-                     const char* proto, bool objectIsConst, long* poffset,
+                     const char* proto, bool objectIsConst, intptr_t* poffset,
                      ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);
    void SetFuncProto(const TClingClassInfo* info, const char* method,
                      const llvm::SmallVectorImpl<clang::QualType>& proto,
-                     long* poffset,
+                     intptr_t* poffset,
                      ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);
    void SetFuncProto(const TClingClassInfo* info, const char* method,
                      const llvm::SmallVectorImpl<clang::QualType>& proto,
-                     bool objectIsConst, long* poffset,
+                     bool objectIsConst, intptr_t* poffset,
                      ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch);
 };
 
diff --git a/src/core/metacling/src/TClingClassInfo.cxx b/src/core/metacling/src/TClingClassInfo.cxx
index 82034ea4e7..58158868d3 100644
--- a/src/core/metacling/src/TClingClassInfo.cxx
+++ b/src/core/metacling/src/TClingClassInfo.cxx
@@ -324,7 +324,7 @@ TClingMethodInfo TClingClassInfo::GetMethod(const char *fname) const
 }
 
 TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
-      const char *proto, long *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
+      const char *proto, intptr_t *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
       EInheritanceMode imode /*= kWithInheritance*/) const
 {
    return GetMethod(fname,proto,false,poffset,mode,imode);
@@ -332,7 +332,7 @@ TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
 
 TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
       const char *proto, bool objectIsConst,
-      long *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
+      intptr_t *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
       EInheritanceMode imode /*= kWithInheritance*/) const
 {
    if (poffset) {
@@ -418,7 +418,7 @@ TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
 
 TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
                                             const llvm::SmallVectorImpl<clang::QualType> &proto,
-                                            long *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
+                                            intptr_t *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
                                             EInheritanceMode imode /*= kWithInheritance*/) const
 {
    return GetMethod(fname,proto,false,poffset,mode,imode);
@@ -426,7 +426,7 @@ TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
 
 TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
                                             const llvm::SmallVectorImpl<clang::QualType> &proto, bool objectIsConst,
-                                            long *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
+                                            intptr_t *poffset, EFunctionMatchMode mode /*= kConversionMatch*/,
                                             EInheritanceMode imode /*= kWithInheritance*/) const
 {
    if (poffset) {
@@ -491,7 +491,7 @@ TClingMethodInfo TClingClassInfo::GetMethod(const char *fname,
 }
 
 TClingMethodInfo TClingClassInfo::GetMethodWithArgs(const char *fname,
-      const char *arglist, long *poffset, EFunctionMatchMode mode /* = kConversionMatch*/,
+      const char *arglist, intptr_t *poffset, EFunctionMatchMode mode /* = kConversionMatch*/,
       EInheritanceMode imode /* = kWithInheritance*/) const
 {
    return GetMethodWithArgs(fname,arglist,false,poffset,mode,imode);
@@ -499,7 +499,7 @@ TClingMethodInfo TClingClassInfo::GetMethodWithArgs(const char *fname,
 
 TClingMethodInfo TClingClassInfo::GetMethodWithArgs(const char *fname,
       const char *arglist, bool objectIsConst,
-      long *poffset, EFunctionMatchMode /*mode = kConversionMatch*/,
+      intptr_t *poffset, EFunctionMatchMode /*mode = kConversionMatch*/,
       EInheritanceMode /* imode = kWithInheritance*/) const
 {
 
@@ -522,7 +522,7 @@ TClingMethodInfo TClingClassInfo::GetMethodWithArgs(const char *fname,
 
    }
    if (poffset) {
-      *poffset = 0L;
+      *poffset = 0;
    }
    if (!IsLoaded()) {
       TClingMethodInfo tmi(fInterp);
@@ -576,12 +576,12 @@ int TClingClassInfo::GetMethodNArg(const char *method, const char *proto,
    return clang_val;
 }
 
-long TClingClassInfo::GetOffset(const CXXMethodDecl* md) const
+ptrdiff_t TClingClassInfo::GetOffset(const CXXMethodDecl* md) const
 {
 
    R__LOCKGUARD(gInterpreterMutex);
 
-   long offset = 0L;
+   ptrdiff_t offset = 0;
    const CXXRecordDecl* definer = md->getParent();
    const CXXRecordDecl* accessor =
       llvm::cast<CXXRecordDecl>(GetDecl());
@@ -833,7 +833,7 @@ bool TClingClassInfo::IsValid() const
 
 bool TClingClassInfo::IsValidMethod(const char *method, const char *proto,
                                     Bool_t objectIsConst,
-                                    long *offset,
+                                    intptr_t *offset,
                                     EFunctionMatchMode mode /*= kConversionMatch*/) const
 {
    // Check if the method with the given prototype exist.
@@ -841,7 +841,7 @@ bool TClingClassInfo::IsValidMethod(const char *method, const char *proto,
       return false;
    }
    if (offset) {
-      *offset = 0L;
+      *offset = 0;
    }
    TClingMethodInfo mi = GetMethod(method, proto, offset, mode);
    return mi.IsValid();
diff --git a/src/core/metacling/src/TClingClassInfo.h b/src/core/metacling/src/TClingClassInfo.h
index ff8ef597e3..2d42a7548b 100644
--- a/src/core/metacling/src/TClingClassInfo.h
+++ b/src/core/metacling/src/TClingClassInfo.h
@@ -98,25 +98,25 @@ public:
    const clang::FunctionTemplateDecl *GetFunctionTemplate(const char *fname) const;
    TClingMethodInfo     GetMethod(const char *fname) const;
    TClingMethodInfo     GetMethod(const char *fname, const char *proto,
-                                  long *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
+                                  intptr_t *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
                                   EInheritanceMode imode = kWithInheritance) const;
    TClingMethodInfo     GetMethodWithArgs(const char *fname, const char *arglist,
-                                  long *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
+                                  intptr_t *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
                                   EInheritanceMode imode = kWithInheritance) const;
    TClingMethodInfo     GetMethod(const char *fname, const char *proto, bool objectIsConst,
-                                  long *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
+                                  intptr_t *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
                                   EInheritanceMode imode = kWithInheritance) const;
    TClingMethodInfo     GetMethodWithArgs(const char *fname, const char *arglist, bool objectIsConst,
-                                  long *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
+                                  intptr_t *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
                                   EInheritanceMode imode = kWithInheritance) const;
    TClingMethodInfo     GetMethod(const char *fname, const llvm::SmallVectorImpl<clang::QualType> &proto,
-                                  long *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
+                                  intptr_t *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
                                   EInheritanceMode imode = kWithInheritance) const;
    TClingMethodInfo     GetMethod(const char *fname, const llvm::SmallVectorImpl<clang::QualType> &proto, bool objectIsConst,
-                                  long *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
+                                  intptr_t *poffset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch,
                                   EInheritanceMode imode = kWithInheritance) const;
    int                  GetMethodNArg(const char *method, const char *proto, Bool_t objectIsConst, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
-   long                 GetOffset(const clang::CXXMethodDecl* md) const;
+   ptrdiff_t            GetOffset(const clang::CXXMethodDecl* md) const;
    ptrdiff_t            GetBaseOffset(TClingClassInfo* toBase, void* address, bool isDerivedObject);
    const clang::Type   *GetType() const { return fType; } // Underlying representation with Double32_t
    std::vector<std::string> GetUsingNamespaces();
@@ -129,7 +129,7 @@ public:
    bool                 IsBase(const char *name) const;
    static bool          IsEnum(cling::Interpreter *interp, const char *name);
    bool                 IsLoaded() const;
-   bool                 IsValidMethod(const char *method, const char *proto, Bool_t objectIsConst, long *offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
+   bool                 IsValidMethod(const char *method, const char *proto, Bool_t objectIsConst, intptr_t *offset, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) const;
    int                  InternalNext();
    int                  Next();
    void                *New(const ROOT::TMetaUtils::TNormalizedCtxt &normCtxt) const;
diff --git a/src/core/metacling/src/TClingDataMemberInfo.cxx b/src/core/metacling/src/TClingDataMemberInfo.cxx
index cebf2425bd..fa0b7a38a6 100644
--- a/src/core/metacling/src/TClingDataMemberInfo.cxx
+++ b/src/core/metacling/src/TClingDataMemberInfo.cxx
@@ -304,7 +304,7 @@ intptr_t TClingDataMemberInfo::Offset()
    using namespace clang;
 
    if (!IsValid()) {
-      return -1L;
+      return (intptr_t)-1;
    }
 
    const Decl *D = GetDecl();
@@ -314,8 +314,7 @@ intptr_t TClingDataMemberInfo::Offset()
       const clang::RecordDecl *RD = FldD->getParent();
       const clang::ASTRecordLayout &Layout = C.getASTRecordLayout(RD);
       uint64_t bits = Layout.getFieldOffset(FldD->getFieldIndex());
-      int64_t offset = C.toCharUnitsFromBits(bits).getQuantity();
-      return static_cast<long>(offset);
+      return C.toCharUnitsFromBits(bits).getQuantity();
    }
    else if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {
       // Could trigger deserialization of decls, in particular in case
@@ -373,9 +372,9 @@ intptr_t TClingDataMemberInfo::Offset()
       return (intptr_t)ECD->getInitVal().getRawData();
 #else
       // In this case in the second part.
-      return reinterpret_cast<long>(((char*)ECD->getInitVal().getRawData())+sizeof(long) );
+      return reinterpret_cast<intptr_t>(((char*)ECD->getInitVal().getRawData())+sizeof(intptr_t) );
 #endif
-   return -1L;
+   return (intptr_t)-1;
 }
 
 long TClingDataMemberInfo::Property() const
diff --git a/src/core/base/src/TROOT.cxx b/src/core/base/src/TROOT.cxx
index e16976afaf..604a74ce8b 100644
--- a/src/core/base/src/TROOT.cxx
+++ b/src/core/base/src/TROOT.cxx
@@ -1179,7 +1179,7 @@ void TROOT::CloseFiles()
          fSockets->SetBit(kMustCleanup);
       }
       CallFunc_t *socketCloser = gInterpreter->CallFunc_Factory();
-      Long_t offset = 0;
+      intptr_t offset = 0;
       TClass *socketClass = TClass::GetClass("TSocket");
       gInterpreter->CallFunc_SetFuncProto(socketCloser, socketClass->GetClassInfo(), "Close", "", &offset);
       if (gInterpreter->CallFunc_IsValid(socketCloser)) {
@@ -1205,7 +1205,7 @@ void TROOT::CloseFiles()
                fClosedObjects->AddLast(socket);
             } else {
                // Crap ... this is not a socket, likely Proof or something, let's try to find a Close
-               Long_t other_offset;
+               intptr_t other_offset;
                CallFunc_t *otherCloser = gInterpreter->CallFunc_Factory();
                gInterpreter->CallFunc_SetFuncProto(otherCloser, socket->IsA()->GetClassInfo(), "Close", "", &other_offset);
                if (gInterpreter->CallFunc_IsValid(otherCloser)) {
diff --git a/src/core/meta/src/TMethodCall.cxx b/src/core/meta/src/TMethodCall.cxx
index 1d5ebe9039..a9c9a991ba 100644
--- a/src/core/meta/src/TMethodCall.cxx
+++ b/src/core/meta/src/TMethodCall.cxx
@@ -460,7 +460,11 @@ void TMethodCall::Execute(void *object, Long_t &retLong)
    void *address = 0;
    if (object) address = (void*)((intptr_t)object + fOffset);
    gCling->SetTempLevel(1);
+#ifdef _WIN64
+   retLong = gCling->CallFunc_ExecInt64(fFunc,address);
+#else
    retLong = gCling->CallFunc_ExecInt(fFunc,address);
+#endif
    gCling->SetTempLevel(-1);
 }
 
@@ -481,7 +485,11 @@ void TMethodCall::Execute(void *object, const char *params, Long_t &retLong)
    void *address = 0;
    if (object) address = (void*)((intptr_t)object + fOffset);
    gCling->SetTempLevel(1);
+#ifdef _WIN64
+   retLong = gCling->CallFunc_ExecInt64(fFunc,address);
+#else
    retLong = gCling->CallFunc_ExecInt(fFunc,address);
+#endif
    gCling->SetTempLevel(-1);
 }
 
diff --git a/src/core/metacling/src/TClingMethodInfo.cxx b/src/core/metacling/src/TClingMethodInfo.cxx
index bbfb6aa962..44ecc2e9c7 100644
--- a/src/core/metacling/src/TClingMethodInfo.cxx
+++ b/src/core/metacling/src/TClingMethodInfo.cxx
@@ -522,8 +522,13 @@ int TClingMethodInfo::InternalNext()
          // enable_if'ed functions.
          // Whatever this finds / instantiates will be picked up by the
          // SpecIterator below.
+         /* WLAV: the above argument makes no rational sense. For sure the
+            code below causes assertion failures in Windows, but more
+            probably needs wholesale disabling/removal */
+#ifndef WIN32
          InstantiateFuncTemplateWithDefaults(templateDecl, fInterp->getSema(),
                                              fInterp->getLookupHelper());
+#endif

          SpecIterator subiter(templateDecl);
          if (subiter) {
diff --git a/src/core/base/src/TROOT.cxx b/src/core/base/src/TROOT.cxx
index 604a74ce8b..4e68101d34 100644
--- a/src/core/base/src/TROOT.cxx
+++ b/src/core/base/src/TROOT.cxx
@@ -2420,7 +2420,12 @@ TROOT::ProcessLineFast(const char *line, Int_t *error)
    if (!fApplication.load())
       TApplication::CreateApplication();

-   Long_t result = 0;
+#ifdef _WIN64
+Long64_t
+#else
+Long_t
+#endif
+   result = 0;

    if (fInterpreter) {
       TInterpreter::EErrorCode *code = (TInterpreter::EErrorCode*)error;
diff --git a/src/core/meta/src/TIsAProxy.cxx b/src/core/meta/src/TIsAProxy.cxx
index 890510168e..16cb8ee392 100644
--- a/src/core/meta/src/TIsAProxy.cxx
+++ b/src/core/meta/src/TIsAProxy.cxx
@@ -95,7 +95,7 @@ TClass* TIsAProxy::operator()(const void *obj)
    }
    // Avoid the case that the first word is a virtual_base_offset_table instead of
    // a virtual_function_table
-   Long_t offset = **(Long_t**)obj;
+   intptr_t offset = **(intptr_t**)obj;
    if ( offset == 0 ) {
       return fClass.load();
    }
diff --git a/src/interpreter/llvm/src/tools/clang/lib/AST/MicrosoftMangle.cpp b/src/interpreter/llvm/src/tools/clang/lib/AST/MicrosoftMangle.cpp
index 24b16f892e..57a5b6f686 100644
--- a/src/interpreter/llvm/src/tools/clang/lib/AST/MicrosoftMangle.cpp
+++ b/src/interpreter/llvm/src/tools/clang/lib/AST/MicrosoftMangle.cpp
@@ -31,6 +31,7 @@
 #include "llvm/Support/JamCRC.h"
 #include "llvm/Support/MD5.h"
 #include "llvm/Support/MathExtras.h"
+#include "llvm/Support/raw_ostream.h"
 
 using namespace clang;
 
@@ -290,7 +291,7 @@ public:
 
   raw_ostream &getStream() const { return Out; }
 
-  void mangle(const NamedDecl *D, StringRef Prefix = "\01?");
+  void mangle(const NamedDecl *D, StringRef Prefix = "?");
   void mangleName(const NamedDecl *ND);
   void mangleFunctionEncoding(const FunctionDecl *FD, bool ShouldMangle);
   void mangleVariableEncoding(const VarDecl *VD);
@@ -2151,11 +2152,13 @@ void MicrosoftCXXNameMangler::mangleType(const UnresolvedUsingType *T,
                                          Qualifiers, SourceRange Range) {
   // Probably should be mangled as a template instantiation; need to see what
   // VC does first.
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this unresolved dependent type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 // <type>        ::= <union-type> | <struct-type> | <class-type> | <enum-type>
@@ -2298,20 +2301,24 @@ void MicrosoftCXXNameMangler::mangleType(const MemberPointerType *T, Qualifiers
 
 void MicrosoftCXXNameMangler::mangleType(const TemplateTypeParmType *T,
                                          Qualifiers, SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this template type parameter type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const SubstTemplateTypeParmPackType *T,
                                          Qualifiers, SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this substituted parameter pack yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 // <type> ::= <pointer-type>
@@ -2420,11 +2427,13 @@ void MicrosoftCXXNameMangler::mangleType(const ExtVectorType *T,
 }
 void MicrosoftCXXNameMangler::mangleType(const DependentSizedExtVectorType *T,
                                          Qualifiers, SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this dependent-sized extended vector type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const ObjCInterfaceType *T, Qualifiers,
@@ -2459,97 +2468,117 @@ void MicrosoftCXXNameMangler::mangleType(const InjectedClassNameType *,
 
 void MicrosoftCXXNameMangler::mangleType(const TemplateSpecializationType *T,
                                          Qualifiers, SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this template specialization type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const DependentNameType *T, Qualifiers,
                                          SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this dependent name type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(
     const DependentTemplateSpecializationType *T, Qualifiers,
     SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this dependent template specialization type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const PackExpansionType *T, Qualifiers,
                                          SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this pack expansion yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const TypeOfType *T, Qualifiers,
                                          SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this typeof(type) yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const TypeOfExprType *T, Qualifiers,
                                          SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this typeof(expression) yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const DecltypeType *T, Qualifiers,
                                          SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this decltype() yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const UnaryTransformType *T,
                                          Qualifiers, SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this unary transform type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const AutoType *T, Qualifiers,
                                          SourceRange Range) {
   assert(T->getDeducedType().isNull() && "expecting a dependent type!");
 
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this 'auto' type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(
     const DeducedTemplateSpecializationType *T, Qualifiers, SourceRange Range) {
   assert(T->getDeducedType().isNull() && "expecting a dependent type!");
 
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this deduced class template specialization type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftCXXNameMangler::mangleType(const AtomicType *T, Qualifiers,
@@ -2568,11 +2597,13 @@ void MicrosoftCXXNameMangler::mangleType(const AtomicType *T, Qualifiers,
 
 void MicrosoftCXXNameMangler::mangleType(const PipeType *T, Qualifiers,
                                          SourceRange Range) {
+/*
   DiagnosticsEngine &Diags = Context.getDiags();
   unsigned DiagID = Diags.getCustomDiagID(DiagnosticsEngine::Error,
     "cannot mangle this OpenCL pipe type yet");
   Diags.Report(Range.getBegin(), DiagID)
     << Range;
+*/
 }
 
 void MicrosoftMangleContextImpl::mangleCXXName(const NamedDecl *D,
@@ -2689,7 +2720,7 @@ MicrosoftMangleContextImpl::mangleVirtualMemPtrThunk(const CXXMethodDecl *MD,
 
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01?";
+  Mangler.getStream() << "?";
   Mangler.mangleVirtualMemPtrThunk(MD, ML);
 }
 
@@ -2698,7 +2729,7 @@ void MicrosoftMangleContextImpl::mangleThunk(const CXXMethodDecl *MD,
                                              raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01?";
+  Mangler.getStream() << "?";
   Mangler.mangleName(MD);
   mangleThunkThisAdjustment(MD, Thunk.This, Mangler, MHO);
   if (!Thunk.Return.isEmpty())
@@ -2719,7 +2750,7 @@ void MicrosoftMangleContextImpl::mangleCXXDtorThunk(
   assert(Type == Dtor_Deleting);
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO, DD, Type);
-  Mangler.getStream() << "\01??_E";
+  Mangler.getStream() << "??_E";
   Mangler.mangleName(DD->getParent());
   mangleThunkThisAdjustment(DD, Adjustment, Mangler, MHO);
   Mangler.mangleFunctionType(DD->getType()->castAs<FunctionProtoType>(), DD);
@@ -2735,9 +2766,9 @@ void MicrosoftMangleContextImpl::mangleCXXVFTable(
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
   if (Derived->hasAttr<DLLImportAttr>())
-    Mangler.getStream() << "\01??_S";
+    Mangler.getStream() << "??_S";
   else
-    Mangler.getStream() << "\01??_7";
+    Mangler.getStream() << "??_7";
   Mangler.mangleName(Derived);
   Mangler.getStream() << "6B"; // '6' for vftable, 'B' for const.
   for (const CXXRecordDecl *RD : BasePath)
@@ -2754,7 +2785,7 @@ void MicrosoftMangleContextImpl::mangleCXXVBTable(
   // is always '7' for vbtables.
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??_8";
+  Mangler.getStream() << "??_8";
   Mangler.mangleName(Derived);
   Mangler.getStream() << "7B";  // '7' for vbtable, 'B' for const.
   for (const CXXRecordDecl *RD : BasePath)
@@ -2765,7 +2796,7 @@ void MicrosoftMangleContextImpl::mangleCXXVBTable(
 void MicrosoftMangleContextImpl::mangleCXXRTTI(QualType T, raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??_R0";
+  Mangler.getStream() << "??_R0";
   Mangler.mangleType(T, SourceRange(), MicrosoftCXXNameMangler::QMM_Result);
   Mangler.getStream() << "@8";
 }
@@ -2781,7 +2812,7 @@ void MicrosoftMangleContextImpl::mangleCXXVirtualDisplacementMap(
     const CXXRecordDecl *SrcRD, const CXXRecordDecl *DstRD, raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??_K";
+  Mangler.getStream() << "??_K";
   Mangler.mangleName(SrcRD);
   Mangler.getStream() << "$C";
   Mangler.mangleName(DstRD);
@@ -2827,7 +2858,7 @@ void MicrosoftMangleContextImpl::mangleCXXCatchableType(
     msvc_hashing_ostream MHO(Stream);
     mangleCXXRTTI(T, MHO);
   }
-  Mangler.getStream() << RTTIMangling.substr(1);
+  Mangler.getStream() << RTTIMangling;//.substr(1);
 
   // VS2015 CTP6 omits the copy-constructor in the mangled name.  This name is,
   // in fact, superfluous but I'm not sure the change was made consciously.
@@ -2839,7 +2870,7 @@ void MicrosoftMangleContextImpl::mangleCXXCatchableType(
     msvc_hashing_ostream MHO(Stream);
     mangleCXXCtor(CD, CT, MHO);
   }
-  Mangler.getStream() << CopyCtorMangling.substr(1);
+  Mangler.getStream() << CopyCtorMangling;//.substr(1);
 
   Mangler.getStream() << Size;
   if (VBPtrOffset == -1) {
@@ -2858,7 +2889,7 @@ void MicrosoftMangleContextImpl::mangleCXXRTTIBaseClassDescriptor(
     uint32_t VBTableOffset, uint32_t Flags, raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??_R1";
+  Mangler.getStream() << "??_R1";
   Mangler.mangleNumber(NVOffset);
   Mangler.mangleNumber(VBPtrOffset);
   Mangler.mangleNumber(VBTableOffset);
@@ -2871,7 +2902,7 @@ void MicrosoftMangleContextImpl::mangleCXXRTTIBaseClassArray(
     const CXXRecordDecl *Derived, raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??_R2";
+  Mangler.getStream() << "??_R2";
   Mangler.mangleName(Derived);
   Mangler.getStream() << "8";
 }
@@ -2880,7 +2911,7 @@ void MicrosoftMangleContextImpl::mangleCXXRTTIClassHierarchyDescriptor(
     const CXXRecordDecl *Derived, raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??_R3";
+  Mangler.getStream() << "??_R3";
   Mangler.mangleName(Derived);
   Mangler.getStream() << "8";
 }
@@ -2896,16 +2927,16 @@ void MicrosoftMangleContextImpl::mangleCXXRTTICompleteObjectLocator(
   llvm::raw_svector_ostream Stream(VFTableMangling);
   mangleCXXVFTable(Derived, BasePath, Stream);
 
-  if (VFTableMangling.startswith("\01??@")) {
+  if (VFTableMangling.startswith("??@")) {
     assert(VFTableMangling.endswith("@"));
     Out << VFTableMangling << "??_R4@";
     return;
   }
 
-  assert(VFTableMangling.startswith("\01??_7") ||
-         VFTableMangling.startswith("\01??_S"));
+  assert(VFTableMangling.startswith("??_7") ||
+         VFTableMangling.startswith("??_S"));
 
-  Out << "\01??_R4" << StringRef(VFTableMangling).drop_front(5);
+  Out << "??_R4" << StringRef(VFTableMangling).drop_front(4);
 }
 
 void MicrosoftMangleContextImpl::mangleSEHFilterExpression(
@@ -2916,7 +2947,7 @@ void MicrosoftMangleContextImpl::mangleSEHFilterExpression(
   // so the numbering here doesn't have to be the same across TUs.
   //
   // <mangled-name> ::= ?filt$ <filter-number> @0
-  Mangler.getStream() << "\01?filt$" << SEHFilterIds[EnclosingDecl]++ << "@0@";
+  Mangler.getStream() << "?filt$" << SEHFilterIds[EnclosingDecl]++ << "@0@";
   Mangler.mangleName(EnclosingDecl);
 }
 
@@ -2928,7 +2959,7 @@ void MicrosoftMangleContextImpl::mangleSEHFinallyBlock(
   // so the numbering here doesn't have to be the same across TUs.
   //
   // <mangled-name> ::= ?fin$ <filter-number> @0
-  Mangler.getStream() << "\01?fin$" << SEHFinallyIds[EnclosingDecl]++ << "@0@";
+  Mangler.getStream() << "?fin$" << SEHFinallyIds[EnclosingDecl]++ << "@0@";
   Mangler.mangleName(EnclosingDecl);
 }
 
@@ -2961,7 +2992,7 @@ void MicrosoftMangleContextImpl::mangleReferenceTemporary(
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
 
-  Mangler.getStream() << "\01?$RT" << ManglingNumber << '@';
+  Mangler.getStream() << "?$RT" << ManglingNumber << '@';
   Mangler.mangle(VD, "");
 }
 
@@ -2970,7 +3001,7 @@ void MicrosoftMangleContextImpl::mangleThreadSafeStaticGuardVariable(
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
 
-  Mangler.getStream() << "\01?$TSS" << GuardNum << '@';
+  Mangler.getStream() << "?$TSS" << GuardNum << '@';
   Mangler.mangleNestedName(VD);
   Mangler.getStream() << "@4HA";
 }
@@ -2992,9 +3023,9 @@ void MicrosoftMangleContextImpl::mangleStaticGuardVariable(const VarDecl *VD,
 
   bool Visible = VD->isExternallyVisible();
   if (Visible) {
-    Mangler.getStream() << (VD->getTLSKind() ? "\01??__J" : "\01??_B");
+    Mangler.getStream() << (VD->getTLSKind() ? "??__J" : "??_B");
   } else {
-    Mangler.getStream() << "\01?$S1@";
+    Mangler.getStream() << "?$S1@";
   }
   unsigned ScopeDepth = 0;
   if (Visible && !getNextDiscriminator(VD, ScopeDepth))
@@ -3014,7 +3045,7 @@ void MicrosoftMangleContextImpl::mangleInitFiniStub(const VarDecl *D,
                                                     raw_ostream &Out) {
   msvc_hashing_ostream MHO(Out);
   MicrosoftCXXNameMangler Mangler(*this, MHO);
-  Mangler.getStream() << "\01??__" << CharCode;
+  Mangler.getStream() << "??__" << CharCode;
   Mangler.mangleName(D);
   if (D->isStaticDataMember()) {
     Mangler.mangleVariableEncoding(D);
@@ -3060,7 +3091,7 @@ void MicrosoftMangleContextImpl::mangleStringLiteral(const StringLiteral *SL,
   // <literal> ::= '??_C@_' <char-type> <literal-length> <encoded-crc>
   //               <encoded-string> '@'
   MicrosoftCXXNameMangler Mangler(*this, Out);
-  Mangler.getStream() << "\01??_C@_";
+  Mangler.getStream() << "??_C@_";
 
   // <char-type>: The "kind" of string literal is encoded into the mangled name.
   if (SL->isWide())
diff --git a/src/interpreter/llvm/src/include/llvm/IR/DataLayout.h b/src/interpreter/llvm/src/include/llvm/IR/DataLayout.h
index daf8f8da68..2052e7eb66 100644
--- a/src/interpreter/llvm/src/include/llvm/IR/DataLayout.h
+++ b/src/interpreter/llvm/src/include/llvm/IR/DataLayout.h
@@ -256,6 +256,12 @@ public:
     return ManglingMode == MM_WinCOFFX86;
   }
 
+  /// Returns true if symbols with leading question marks should not receive IR
+  /// mangling. True for Windows mangling modes.
+  bool doNotMangleLeadingQuestionMark() const {
+     return ManglingMode == MM_WinCOFF || ManglingMode == MM_WinCOFFX86;
+  }
+
   bool hasLinkerPrivateGlobalPrefix() const { return ManglingMode == MM_MachO; }
 
   StringRef getLinkerPrivateGlobalPrefix() const {
diff --git a/src/interpreter/llvm/src/lib/IR/Mangler.cpp b/src/interpreter/llvm/src/lib/IR/Mangler.cpp
index 03723bfd2d..ef357377ef 100644
--- a/src/interpreter/llvm/src/lib/IR/Mangler.cpp
+++ b/src/interpreter/llvm/src/lib/IR/Mangler.cpp
@@ -44,6 +44,9 @@ static void getNameWithPrefixImpl(raw_ostream &OS, const Twine &GVName,
     return;
   }
 
+  if (DL.doNotMangleLeadingQuestionMark() && Name[0] == '?')
+    Prefix = '\0';
+
   if (PrefixTy == Private)
     OS << DL.getPrivateGlobalPrefix();
   else if (PrefixTy == LinkerPrivate)
@@ -135,8 +138,13 @@ void Mangler::getNameWithPrefix(raw_ostream &OS, const GlobalValue *GV,
   // Mangle functions with Microsoft calling conventions specially.  Only do
   // this mangling for x86_64 vectorcall and 32-bit x86.
   const Function *MSFunc = dyn_cast<Function>(GV);
-  if (Name.startswith("\01"))
-    MSFunc = nullptr; // Don't mangle when \01 is present.
+ 
+  // Don't add byte count suffixes when '\01' or '?' are in the first
+  // character.
+  if (Name.startswith("\01") ||
+      (DL.doNotMangleLeadingQuestionMark() && Name.startswith("?")))
+    MSFunc = nullptr;
+ 
   CallingConv::ID CC =
       MSFunc ? MSFunc->getCallingConv() : (unsigned)CallingConv::C;
   if (!DL.hasMicrosoftFastStdCallMangling() &&
diff --git a/src/interpreter/llvm/src/tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp b/src/interpreter/llvm/src/tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp
index 1bd2937e47..dbc7ce22f5 100644
--- a/src/interpreter/llvm/src/tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp
+++ b/src/interpreter/llvm/src/tools/clang/lib/CodeGen/MicrosoftCXXABI.cpp
@@ -3347,7 +3347,7 @@ CGCXXABI *clang::CodeGen::CreateMicrosoftCXXABI(CodeGenModule &CGM) {
 //   mangled into them so they can be aggressively deduplicated by the linker.
 
 static llvm::GlobalVariable *getTypeInfoVTable(CodeGenModule &CGM) {
-  StringRef MangledName("\01??_7type_info@@6B@");
+  StringRef MangledName("??_7type_info@@6B@");
   if (auto VTable = CGM.getModule().getNamedGlobal(MangledName))
     return VTable;
   return new llvm::GlobalVariable(CGM.getModule(), CGM.Int8PtrTy,
diff --git a/src/core/metacling/src/CMakeLists.txt b/src/core/metacling/src/CMakeLists.txt
index 483ba33620..a9eed4633d 100644
--- a/src/core/metacling/src/CMakeLists.txt
+++ b/src/core/metacling/src/CMakeLists.txt
@@ -101,6 +101,23 @@ if(MSVC)
       ?setValueNoAlloc@internal@runtime@cling@@YAXPEAX00DPEBX@Z
       ?setValueNoAlloc@internal@runtime@cling@@YAXPEAX00D_K@Z
       ?setValueWithAlloc@internal@runtime@cling@@YAPEAXPEAX00D@Z
+      ??1Value@cling@@QEAA@XZ
+      ??_7type_info@@6B@
+      #?__type_info_root_node@@3U__type_info_node@@A
+      ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z
+      ??2@YAPEAX_K@Z
+      ??3@YAXPEAX@Z
+      ??3@YAXPEAX_K@Z
+      #??2@YAPEAX_KPEAX@Z
+      ??_U@YAPEAX_K@Z
+      ??_V@YAXPEAX@Z
+      memcpy
+      memmove
+      memset
+      malloc
+      calloc
+      free
+      ?EvaluateDynamicExpression@internal@runtime@cling@@YA?AVValue@3@PEAVInterpreter@3@PEAVDynamicExprInfo@123@PEAVDeclContext@clang@@@Z
     )
   elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
     set(cling_exports
@@ -111,6 +128,12 @@ if(MSVC)
       ??_U@YAPAXI@Z
       ??_V@YAXPAX@Z
       ??_V@YAXPAXI@Z
+      memcpy
+      memmove
+      memset
+      malloc
+      calloc
+      free
       ??_7type_info@@6B@
       ?__type_info_root_node@@3U__type_info_node@@A
       ?nothrow@std@@3Unothrow_t@1@B
