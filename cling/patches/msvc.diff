diff --git a/src/core/foundation/inc/ROOT/TypeTraits.hxx b/core/foundation/inc/ROOT/TypeTraits.hxx
index 55494193c8..a09f591cff 100644
--- a/src/core/foundation/inc/ROOT/TypeTraits.hxx
+++ b/src/core/foundation/inc/ROOT/TypeTraits.hxx
@@ -33,6 +33,9 @@ namespace Detail {
 template <typename T> constexpr auto HasCallOp(int /*goodOverload*/) -> decltype(&T::operator(), true) { return true; }
 template <typename T> constexpr bool HasCallOp(char /*badOverload*/) { return false; }
 
+// Don't need CallableTraits and it fails for Windows (internal compiler error); for ease of
+// testing, drop it completely
+#ifdef KEEP_CALLABLE_TRAITS
 /// Extract types from the signature of a callable object. See CallableTraits.
 template <typename T, bool HasCallOp = ROOT::Detail::HasCallOp<T>(0)>
 struct CallableTraitsImpl {};
@@ -76,6 +79,7 @@ struct CallableTraitsImpl<R(Args...), false> {
    using arg_types_nodecay = ROOT::TypeTraits::TypeList<Args...>;
    using ret_type = R;
 };
+#endif // KEEP_CALLABLE_TRAITS
 } // end ns Detail
 
 namespace TypeTraits {
@@ -147,12 +151,15 @@ struct IsUnsignedNumeral : std::integral_constant<bool,
 template<class T>
 using IsFloatNumeral = std::is_floating_point<T>;
 
+// See above: don't need this and it causes internal compiler errors on Windows
+#ifdef KEEP_CALLABLE_TRAITS
 /// Extract types from the signature of a callable object.
 /// The `CallableTraits` struct contains three type aliases:
 ///   - arg_types: a `TypeList` of all types in the signature, decayed through std::decay
 ///   - arg_types_nodecay: a `TypeList` of all types in the signature, including cv-qualifiers
 template<typename F>
 using CallableTraits = ROOT::Detail::CallableTraitsImpl<F>;
+#endif
 
 // Return first of a variadic list of types.
 template <typename T, typename... Rest>
diff --git a/src/core/clingutils/CMakeLists.txt b/src/core/clingutils/CMakeLists.txt
index 4be71a05fb..11535a0105 100644
--- a/src/core/clingutils/CMakeLists.txt
+++ b/src/core/clingutils/CMakeLists.txt
@@ -127,6 +127,9 @@ set(stamp_file ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/LLVMRES.stamp)
 if(MSVC)
   add_custom_command(OUTPUT ${stamp_file}
         COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include
+        COMMAND ${CMAKE_COMMAND} -E copy_directory
+        ${CLANG_RESOURCE_DIR}
+        ${CMAKE_BINARY_DIR}/etc/cling/lib/clang/${CLANG_RESOURCE_DIR_VERSION}/include
         ${copy_commands}
         COMMAND ${CMAKE_COMMAND} -E touch ${stamp_file}
         DEPENDS ${files_to_copy}
diff --git a/src/interpreter/cling/lib/Interpreter/Interpreter.cpp b/src/interpreter/cling/lib/Interpreter/Interpreter.cpp
index 533eea318b..e2172508f6 100644
--- a/src/interpreter/cling/lib/Interpreter/Interpreter.cpp
+++ b/src/interpreter/cling/lib/Interpreter/Interpreter.cpp
@@ -1580,6 +1580,12 @@ namespace cling {
     // Return a symbol's address, and whether it was jitted.
     std::string mangledName;
     utils::Analyze::maybeMangleDeclName(GD, mangledName);
+#if defined(LLVM_ON_WIN32)
+    if (mangledName.size() > 2 && mangledName[1] == '?' && \
+         mangledName.find(std::string("?__cling_Un1Qu")) == std::string::npos) {
+       mangledName.erase(0,1);
+    }
+#endif
     return getAddressOfGlobal(mangledName, fromJIT);
   }

   void* Interpreter::getAddressOfGlobal(llvm::StringRef SymName,
