diff --git a/src/core/foundation/inc/ROOT/TypeTraits.hxx b/core/foundation/inc/ROOT/TypeTraits.hxx
index 55494193c8..a09f591cff 100644
--- a/src/core/foundation/inc/ROOT/TypeTraits.hxx
+++ b/src/core/foundation/inc/ROOT/TypeTraits.hxx
@@ -33,6 +33,9 @@ namespace Detail {
 template <typename T> constexpr auto HasCallOp(int /*goodOverload*/) -> decltype(&T::operator(), true) { return true; }
 template <typename T> constexpr bool HasCallOp(char /*badOverload*/) { return false; }
 
+// Don't need CallableTraits and it fails for Windows (internal compiler error); for ease of
+// testing, drop it completely
+#ifdef KEEP_CALLABLE_TRAITS
 /// Extract types from the signature of a callable object. See CallableTraits.
 template <typename T, bool HasCallOp = ROOT::Detail::HasCallOp<T>(0)>
 struct CallableTraitsImpl {};
@@ -76,6 +79,7 @@ struct CallableTraitsImpl<R(Args...), false> {
    using arg_types_nodecay = ROOT::TypeTraits::TypeList<Args...>;
    using ret_type = R;
 };
+#endif // KEEP_CALLABLE_TRAITS
 } // end ns Detail
 
 namespace TypeTraits {
@@ -147,12 +151,15 @@ struct IsUnsignedNumeral : std::integral_constant<bool,
 template<class T>
 using IsFloatNumeral = std::is_floating_point<T>;
 
+// See above: don't need this and it causes internal compiler errors on Windows
+#ifdef KEEP_CALLABLE_TRAITS
 /// Extract types from the signature of a callable object.
 /// The `CallableTraits` struct contains three type aliases:
 ///   - arg_types: a `TypeList` of all types in the signature, decayed through std::decay
 ///   - arg_types_nodecay: a `TypeList` of all types in the signature, including cv-qualifiers
 template<typename F>
 using CallableTraits = ROOT::Detail::CallableTraitsImpl<F>;
+#endif
 
 // Return first of a variadic list of types.
 template <typename T, typename... Rest>
