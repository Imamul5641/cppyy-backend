diff --git a/src/core/metacling/src/TClingMethodInfo.cxx b/src/core/metacling/src/TClingMethodInfo.cxx
index 578ffac..68426a7 100644
--- a/src/core/metacling/src/TClingMethodInfo.cxx
+++ b/src/core/metacling/src/TClingMethodInfo.cxx
@@ -538,6 +538,9 @@ long TClingMethodInfo::Property() const
    long property = 0L;
    property |= kIsCompiled;
    const clang::FunctionDecl *fd = GetMethodDecl();
+   if (fd->isDeleted())
+      return 0L;
+
    if (fd->isConstexpr())
       property |= kIsConstexpr;
 
@@ -630,6 +633,9 @@ long TClingMethodInfo::ExtraProperty() const
    }
    long property = 0;
    const clang::FunctionDecl *fd = GetMethodDecl();
+   if (fd->isDeleted())
+      return 0L;
+
    if (fd->isOverloadedOperator())
       property |= kIsOperator;
    if (llvm::isa<clang::CXXConversionDecl>(fd))
diff --git a/src/core/metacling/src/TClingCallFunc.cxx b/src/core/metacling/src/TClingCallFunc.cxx
index e2dda52..e3bed0b 100644
--- a/src/core/metacling/src/TClingCallFunc.cxx
+++ b/src/core/metacling/src/TClingCallFunc.cxx
@@ -559,9 +559,22 @@ void TClingCallFunc::make_narg_call(const std::string &return_type, const unsign
          callbuf << "*(" << type_name.c_str() << "**)args["
                  << i << "]";
       } else {
-         // pointer falls back to non-pointer case; the argument preserves
-         // the "pointerness" (i.e. doesn't reference the value).
-         callbuf << "*(" << type_name.c_str() << "*)args[" << i << "]";
+         // By-value construction; this may either copy or move, but there is no
+         // information here in terms of intent. Thus, simply assume that the intent
+         // is to move if there is no viable copy constructor (ie. if the code would
+         // otherwise fail to even compile).
+
+         // There does not appear to be a simple way of determining whether a viable
+         // copy constructor exists, so check for the most common case: the trivial
+         // one, but not uniquely available, while there is a move constructor.
+         if (rtdecl && (rtdecl->hasTrivialCopyConstructor() && !rtdecl->hasSimpleCopyConstructor()) \
+               && rtdecl->hasMoveConstructor()) {
+            // move construction as needed for classes (note that this is implicit)
+            callbuf << "std::move(*(" << type_name.c_str() << "*)args[" << i << "])";
+         } else {
+            // otherwise, and for builtins, use copy construction of temporary*/
+            callbuf << "*(" << type_name.c_str() << "*)args[" << i << "]";
+         }
       }
    }
    callbuf << ")";
