diff --git a/src/core/meta/src/TListOfDataMembers.cxx b/src/core/meta/src/TListOfDataMembers.cxx
index caac907..7d38d13 100644
--- a/src/core/meta/src/TListOfDataMembers.cxx
+++ b/src/core/meta/src/TListOfDataMembers.cxx
@@ -439,7 +440,7 @@ void TListOfDataMembers::Load()
 
    // Treat the complex<float>, complex<double> in a special way, i.e. replacing
    // the datamembers with the ones of _root_std_complex<T>
-   bool skipChecks = false;
+   bool skipChecks = true;
    if (fClass) {
       auto complexType = TClassEdit::GetComplexType(fClass->GetName());
       switch(complexType) {
@@ -480,7 +481,7 @@ void TListOfDataMembers::Load()
       if (gInterpreter->DataMemberInfo_IsValid(t)) {
          // Get will check if there is already there or create a new one
          // (or re-use a previously unloaded version).
-         Get(t,skipChecks);
+         Get(t, skipChecks);
       }
    }
    gInterpreter->DataMemberInfo_Delete(t);
diff --git a/src/core/metacling/src/TClingDataMemberInfo.cxx b/src/core/metacling/src/TClingDataMemberInfo.cxx
index 354ae89..5f8a75f 100644
--- a/src/core/metacling/src/TClingDataMemberInfo.cxx
+++ b/src/core/metacling/src/TClingDataMemberInfo.cxx
@@ -113,6 +114,14 @@ void TClingDataMemberInfo::CheckForIoTypeAndName() const
 
 }
 
+const clang::Decl* TClingDataMemberInfo::GetDecl() const {
+   if (const clang::Decl* SingleDecl = TClingDeclInfo::GetDecl())
+      return SingleDecl;
+   if (clang::UsingShadowDecl* shadow_decl = llvm::dyn_cast<clang::UsingShadowDecl>(*fIter))
+      return shadow_decl->getTargetDecl();
+   return *fIter;
+}
+
 TDictionary::DeclId_t TClingDataMemberInfo::GetDeclId() const
 {
    if (!IsValid()) {
@@ -310,6 +319,13 @@ int TClingDataMemberInfo::InternalNext()
          // and namespace variable members.
          return 1;
       }
+      if (clang::UsingShadowDecl* shadow_decl = llvm::dyn_cast<clang::UsingShadowDecl>(*fIter)) {
+          clang::Decl::Kind target_DK = shadow_decl->getTargetDecl()->getKind();
+          if ((target_DK == clang::Decl::Field) || (target_DK == clang::Decl::EnumConstant) ||
+              (target_DK == clang::Decl::Var)) {
+             return 1;       // as above
+          }
+      }
       // Collect internal `__cling_N5xxx' inline namespaces; they will be traversed later
       if (auto NS = dyn_cast<NamespaceDecl>(*fIter)) {
          if (NS->getDeclContext()->isTranslationUnit() && NS->isInlineNamespace())
@@ -420,11 +436,16 @@ long TClingDataMemberInfo::Property() const
       return 0L;
    }
    long property = 0L;
-   const clang::Decl *declaccess = GetDecl();
-   if (declaccess->getDeclContext()->isTransparentContext()) {
-      declaccess = llvm::dyn_cast<clang::Decl>(declaccess->getDeclContext());
-      if (!declaccess) declaccess = GetDecl();
+   const clang::Decl *decl = GetDecl();
+   if (decl->getDeclContext()->isTransparentContext()) {
+      decl = llvm::dyn_cast<clang::Decl>(decl->getDeclContext());
+      if (!decl) decl = GetDecl();
    }
+
+   const clang::Decl *declaccess = decl;
+   if (!TClingDeclInfo::GetDecl() && llvm::dyn_cast<clang::UsingShadowDecl>(*fIter))
+      declaccess = *fIter;
+
    switch (declaccess->getAccess()) {
       case clang::AS_public:
          property |= kIsPublic;
@@ -451,7 +472,7 @@ long TClingDataMemberInfo::Property() const
          property |= kIsConstexpr;
       if (vard->getStorageClass() == clang::SC_Static) {
          property |= kIsStatic;
-      } else if (declaccess->getDeclContext()->isNamespace()) {
+      } else if (decl->getDeclContext()->isNamespace()) {
          // Data members of a namespace are global variable which were
          // considered to be 'static' in the CINT (and thus ROOT) scheme.
          property |= kIsStatic;
diff --git a/src/core/metacling/src/TClingDataMemberInfo.h b/src/core/metacling/src/TClingDataMemberInfo.h
index 7d04549..b4f11fa 100644
--- a/src/core/metacling/src/TClingDataMemberInfo.h
+++ b/src/core/metacling/src/TClingDataMemberInfo.h
@@ -125,11 +125,7 @@ public:
 
    int                ArrayDim() const;
    TClingClassInfo   *GetClassInfo() const { return fClassInfo; }
-   const clang::Decl *GetDecl() const override {
-     if (const clang::Decl* SingleDecl = TClingDeclInfo::GetDecl())
-       return SingleDecl;
-     return *fIter;
-   }
+   const clang::Decl *GetDecl() const override;
    DeclId_t           GetDeclId() const;
    int                MaxIndex(int dim) const;
    int                InternalNext();
