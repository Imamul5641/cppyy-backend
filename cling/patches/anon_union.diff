diff --git a/src/core/meta/src/TClass.cxx b/src/core/meta/src/TClass.cxx
index 29eb7f622f..72455671ad 100644
--- a/src/core/meta/src/TClass.cxx
+++ b/src/core/meta/src/TClass.cxx
@@ -2955,7 +2955,7 @@ TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent)
    }
 
    std::string normalizedName;
-   Bool_t checkTable = kFALSE;
+   Bool_t checkTable = load;
 
    if (!cl) {
       {
diff --git a/src/core/metacling/src/TCling.cxx b/src/core/metacling/src/TCling.cxx
index 5894a0863b..354b1c4069 100644
--- a/src/core/metacling/src/TCling.cxx
+++ b/src/core/metacling/src/TCling.cxx
@@ -3660,7 +3736,7 @@ void TCling::SetClassInfo(TClass* cl, Bool_t reload)
    Bool_t zombieCandidate = kFALSE;
    if (
       info->IsValid() &&
-      !(info->Property() & (kIsClass | kIsStruct | kIsNamespace))
+      !(info->Property() & (kIsClass | kIsStruct | kIsUnion | kIsNamespace))
    ) {
       zombieCandidate = kTRUE;
    }
@@ -3806,8 +3882,8 @@ TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamesp
          SetClassAutoloading(storeAutoload);
          return kUnknown;
       }
-      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsNamespace :
-                                                     kIsClass | kIsStruct | kIsNamespace | kIsEnum | kIsUnion;
+      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsUnion | kIsNamespace :
+                                                     kIsClass | kIsStruct | kIsUnion | kIsNamespace | kIsEnum;

       if (tci.Property() & propertiesMask) {
          bool hasClassDefInline = false;
@@ -7567,6 +7599,17 @@ Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const
    else if (decl->getDeclContext()->isTransparentContext() &&
             decl->getDeclContext()->getParent()->Equals(ctxt))
       return kTRUE;
+   else {
+       const clang::RecordDecl* rec = llvm::dyn_cast<clang::RecordDecl>(decl->getDeclContext());
+       const clang::DeclContext* parent = decl->getDeclContext()->getParent();
+       while (rec && rec->isAnonymousStructOrUnion()) {
+           if (parent->Equals(ctxt))
+               return kTRUE;
+           rec = llvm::dyn_cast<clang::RecordDecl>(parent);
+           parent = parent->getParent();
+       }
+   }
+
    return kFALSE;
 }
 
diff --git a/src/core/metacling/src/TClingDataMemberInfo.cxx b/src/core/metacling/src/TClingDataMemberInfo.cxx
index 488f698305..3f6e4c8c5f 100644
--- a/src/core/metacling/src/TClingDataMemberInfo.cxx
+++ b/src/core/metacling/src/TClingDataMemberInfo.cxx
@@ -282,13 +283,26 @@ int TClingDataMemberInfo::InternalNext()
       clang::Decl::Kind DK = fIter->getKind();
       if (DK == clang::Decl::Enum) {
          // We have an enum, recurse into these.
-         // Note: For C++11 we will have to check for a transparent context.
+         // Note: For C++11 we will have to check for a transparent context (done from TListOfDataMembers::Load())
          fIterStack.push_back(fIter);
          cling::Interpreter::PushTransactionRAII RAII(fInterp);
          fIter = llvm::dyn_cast<clang::DeclContext>(*fIter)->decls_begin();
          increment = false; // avoid the next incrementation
          continue;
       }
+      if (DK == clang::Decl::Field) {
+         FieldDecl* ff = dyn_cast<FieldDecl>(*fIter);
+         if (ff->isAnonymousStructOrUnion()) {
+            cling::Interpreter::PushTransactionRAII RAII(fInterp);
+            const auto* rec = ff->getType()->getAs<RecordType>()->getDecl();
+            if (rec) {
+               fIterStack.push_back(fIter);
+               fIter = rec->decls_begin();
+               increment = false; // avoid the next incrementation
+               continue;
+            }
+         }
+      }
       if ((DK == clang::Decl::Field) || (DK == clang::Decl::EnumConstant) ||
           (DK == clang::Decl::Var)) {
          // Stop on class data members, enumerator values,
@@ -314,8 +327,24 @@ long TClingDataMemberInfo::Offset()
       const clang::RecordDecl *RD = FldD->getParent();
       const clang::ASTRecordLayout &Layout = C.getASTRecordLayout(RD);
       uint64_t bits = Layout.getFieldOffset(FldD->getFieldIndex());
-      int64_t offset = C.toCharUnitsFromBits(bits).getQuantity();
-      return static_cast<long>(offset);
+      intptr_t offset = C.toCharUnitsFromBits(bits).getQuantity();
+      while (RD->isAnonymousStructOrUnion()) {
+         // calculate the offset of the union in its parent (TODO: this seems silly)
+         const clang::RecordDecl* anon = RD;
+         RD = llvm::dyn_cast<RecordDecl>(anon->getParent());
+         for (auto f = RD->field_begin(); f != RD->field_end(); ++f) {
+            auto* rt = f->getType()->getAs<RecordType>();
+            if (!rt) continue;
+            if (anon == rt->getDecl()) {
+               FldD = *f;
+               break;
+            }
+         }
+         const auto& ll = C.getASTRecordLayout(RD);
+         uint64_t boff = ll.getFieldOffset(FldD->getFieldIndex());
+         offset += C.toCharUnitsFromBits(boff).getQuantity();
+      }
+      return offset;
    }
    else if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {
       // Could trigger deserialization of decls, in particular in case
