diff --git a/src/core/meta/src/TClass.cxx b/src/core/meta/src/TClass.cxx
index 29eb7f622f..72455671ad 100644
--- a/src/core/meta/src/TClass.cxx
+++ b/src/core/meta/src/TClass.cxx
@@ -2567,7 +2567,7 @@ TClass *TClass::GetActualClass(const void *object) const
          if (GetClassInfo() && gCling->ClassInfo_HasMethod(fClassInfo,"IsA")) {
             isa = (TVirtualIsAProxy*)gROOT->ProcessLineFast(TString::Format("new ::TInstrumentedIsAProxy<%s>(0);",GetName()));
          }
-         else {
+         else if (!strstr(GetName(), "(anonymous)")) {
             isa = (TVirtualIsAProxy*)gROOT->ProcessLineFast(TString::Format("new ::TIsAProxy(typeid(%s));",GetName()));
          }
          if (isa) {
@@ -2907,7 +2907,7 @@ TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent)
 {
    if (!name || !name[0]) return 0;
 
-   if (strstr(name, "(anonymous)")) return 0;
+   //if (strstr(name, "(anonymous)")) return 0;
    if (strncmp(name,"class ",6)==0) name += 6;
    if (strncmp(name,"struct ",7)==0) name += 7;
 
@@ -2970,7 +2970,7 @@ TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent)
    }
 
    std::string normalizedName;
-   Bool_t checkTable = kFALSE;
+   Bool_t checkTable = load;
 
    if (!cl) {
       {
@@ -3089,24 +3089,26 @@ TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent)
       } else if (cci) {
          // Get the normalized name based on the decl (currently the only way
          // to get the part to add or drop the default arguments as requested by the user)
-         std::string alternative;
-         gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);
-         const char *altname = alternative.c_str();
-         if (strncmp(altname, "std::", 5) == 0) {
-            // For namespace (for example std::__1), GetInterpreterTypeName does
-            // not strip std::, so we must do it explicitly here.
-            altname += 5;
-         }
-         if (altname != normalizedName && strcmp(altname, name) != 0) {
-            // altname now contains the full name of the class including a possible
-            // namespace if there has been a using namespace statement.
+         if (normalizedName.find("(anonymous)") == std::string::npos) {
+            std::string alternative;
+            gInterpreter->GetInterpreterTypeName(normalizedName.c_str(), alternative, kTRUE);
+            const char *altname = alternative.c_str();
+            if (strncmp(altname, "std::", 5) == 0) {
+               // For namespace (for example std::__1), GetInterpreterTypeName does
+               // not strip std::, so we must do it explicitly here.
+               altname += 5;
+            }
+            if (altname != normalizedName && strcmp(altname, name) != 0) {
+               // altname now contains the full name of the class including a possible
+               // namespace if there has been a using namespace statement.
 
-            // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname)
-            // the TClassEdit normalization and the TMetaUtils normalization leads to
-            // two different space layout.  To avoid an infinite recursion, we also
-            // add the test on (altname != name)
+               // At least in the case C<string [2]> (normalized) vs C<string[2]> (altname)
+               // the TClassEdit normalization and the TMetaUtils normalization leads to
+               // two different space layout.  To avoid an infinite recursion, we also
+               // add the test on (altname != name)
 
-            return GetClass(altname, load);
+               return GetClass(altname, load);
+            }
          }
 
          TClass *ncl = gInterpreter->GenerateTClass(normalizedName.c_str(), /* emulation = */ kFALSE, silent);
diff --git a/src/core/metacling/src/TCling.cxx b/src/core/metacling/src/TCling.cxx
index 5894a0863b..354b1c4069 100644
--- a/src/core/metacling/src/TCling.cxx
+++ b/src/core/metacling/src/TCling.cxx
@@ -3821,7 +3897,7 @@ void TCling::SetClassInfo(TClass* cl, Bool_t reload)
    Bool_t zombieCandidate = kFALSE;
    if (
       info->IsValid() &&
-      !(info->Property() & (kIsClass | kIsStruct | kIsNamespace))
+      !(info->Property() & (kIsClass | kIsStruct | kIsUnion | kIsNamespace))
    ) {
       zombieCandidate = kTRUE;
    }
@@ -3930,6 +4009,31 @@ TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamesp
                      gDebug > 5 ? cling::LookupHelper::WithDiagnostics
                      : cling::LookupHelper::NoDiagnostics,
                      &type, /* intantiateTemplate= */ false );
+   if (!decl) {
+      std::string strname{classname};
+      std::string::size_type pos = strname.rfind("::(anonymous");
+      if (pos != std::string::npos) {
+         const clang::Decl* anon = lh.findScope(strname.substr(0, pos),
+                                   gDebug > 5 ? cling::LookupHelper::WithDiagnostics
+                                   : cling::LookupHelper::NoDiagnostics,
+                                   &type, /* intantiateTemplate= */ true );
+         if (anon && llvm::dyn_cast<clang::RecordDecl>(anon)) {
+            const clang::RecordDecl* RD = llvm::dyn_cast<clang::RecordDecl>(anon);
+            for (auto f = RD->field_begin(); f != RD->field_end(); ++f) {
+            // if the field has a name, an unnamed union is no longer considered anonymous
+            // per Clang, as it does not put its names in the enclosing scope
+               auto* rt = f->getType()->getAs<RecordType>();
+               if (!rt) continue;
+               auto* RD = rt->getDecl();
+               if (RD->isAnonymousStructOrUnion() || (RD->isUnion() && RD->getNameAsString().empty())) {
+                   decl = RD;
+                   break;
+               }
+            }
+         }
+      }
+   }
+
    if (!decl) {
       std::string buf = TClassEdit::InsertStd(classname);
       decl = lh.findScope(buf,
@@ -3970,8 +4021,8 @@ TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamesp
          SetClassAutoloading(storeAutoload);
          return kUnknown;
       }
-      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsNamespace :
-                                                     kIsClass | kIsStruct | kIsNamespace | kIsEnum | kIsUnion;
+      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsUnion | kIsNamespace :
+                                                     kIsClass | kIsStruct | kIsUnion | kIsNamespace | kIsEnum;

       if (tci.Property() & propertiesMask) {
          bool hasClassDefInline = false;
@@ -4254,7 +4347,7 @@ TClass *TCling::GenerateTClass(const char *classname, Bool_t emulation, Bool_t s
       version = TClass::GetClass("TVirtualStreamerInfo")->GetClassVersion();
    }
    TClass *cl = new TClass(classname, version, silent);
-   if (emulation) {
+   if (emulation || strstr(classname, "(anonymous)")) {
       cl->SetBit(TClass::kIsEmulation);
    } else {
       // Set the class version if the class is versioned.
@@ -7946,6 +7953,17 @@ Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const
              || decl->getDeclContext()->isInlineNamespace())
             && decl->getDeclContext()->getParent()->Equals(ctxt))
       return kTRUE;
+   else {
+       const clang::RecordDecl* rec = llvm::dyn_cast<clang::RecordDecl>(decl->getDeclContext());
+       const clang::DeclContext* parent = decl->getDeclContext()->getParent();
+       while (rec && rec->isAnonymousStructOrUnion()) {
+           if (parent->Equals(ctxt))
+               return kTRUE;
+           rec = llvm::dyn_cast<clang::RecordDecl>(parent);
+           parent = parent->getParent();
+       }
+   }
+
    return kFALSE;
 }
 
diff --git a/src/core/metacling/src/TClingDataMemberInfo.cxx b/src/core/metacling/src/TClingDataMemberInfo.cxx
index 488f698305..3f6e4c8c5f 100644
--- a/src/core/metacling/src/TClingDataMemberInfo.cxx
+++ b/src/core/metacling/src/TClingDataMemberInfo.cxx
@@ -284,13 +285,26 @@ int TClingDataMemberInfo::InternalNext()
       clang::Decl::Kind DK = fIter->getKind();
       if (DK == clang::Decl::Enum) {
          // We have an enum, recurse into these.
-         // Note: For C++11 we will have to check for a transparent context.
+         // Note: For C++11 we will have to check for a transparent context (done from TListOfDataMembers::Load())
          fIterStack.push_back(fIter);
          cling::Interpreter::PushTransactionRAII RAII(fInterp);
          fIter = llvm::dyn_cast<clang::DeclContext>(*fIter)->decls_begin();
          increment = false; // avoid the next incrementation
          continue;
       }
+      if (DK == clang::Decl::Field) {
+         FieldDecl* ff = dyn_cast<FieldDecl>(*fIter);
+         if (ff->isAnonymousStructOrUnion()) {
+            cling::Interpreter::PushTransactionRAII RAII(fInterp);
+            const auto* rec = ff->getType()->getAs<RecordType>()->getDecl();
+            if (rec) {
+               fIterStack.push_back(fIter);
+               fIter = rec->decls_begin();
+               increment = false; // avoid the next incrementation
+               continue;
+            }
+         }
+      }
       if ((DK == clang::Decl::Field) || (DK == clang::Decl::EnumConstant) ||
           (DK == clang::Decl::Var)) {
          // Stop on class data members, enumerator values,
@@ -321,8 +334,24 @@ long TClingDataMemberInfo::Offset()
       const clang::RecordDecl *RD = FldD->getParent();
       const clang::ASTRecordLayout &Layout = C.getASTRecordLayout(RD);
       uint64_t bits = Layout.getFieldOffset(FldD->getFieldIndex());
-      int64_t offset = C.toCharUnitsFromBits(bits).getQuantity();
-      return static_cast<long>(offset);
+      intptr_t offset = C.toCharUnitsFromBits(bits).getQuantity();
+      while (RD->isAnonymousStructOrUnion()) {
+         // calculate the offset of the union in its parent (TODO: this seems silly)
+         const clang::RecordDecl* anon = RD;
+         RD = llvm::dyn_cast<RecordDecl>(anon->getParent());
+         for (auto f = RD->field_begin(); f != RD->field_end(); ++f) {
+            auto* rt = f->getType()->getAs<RecordType>();
+            if (!rt) continue;
+            if (anon == rt->getDecl()) {
+               FldD = *f;
+               break;
+            }
+         }
+         const auto& ll = C.getASTRecordLayout(RD);
+         uint64_t boff = ll.getFieldOffset(FldD->getFieldIndex());
+         offset += C.toCharUnitsFromBits(boff).getQuantity();
+      }
+      return offset;
    }
    else if (const VarDecl *VD = dyn_cast<VarDecl>(D)) {
       // Could trigger deserialization of decls, in particular in case
diff --git a/src/core/metacling/src/TClingClassInfo.cxx b/src/core/metacling/src/TClingClassInfo.cxx
index f99c45e93f..c63391f47e 100644
--- a/src/core/metacling/src/TClingClassInfo.cxx
+++ b/src/core/metacling/src/TClingClassInfo.cxx
@@ -89,6 +89,30 @@ TClingClassInfo::TClingClassInfo(cling::Interpreter *interp, const char *name)
                                    gDebug > 5 ? cling::LookupHelper::WithDiagnostics
                                    : cling::LookupHelper::NoDiagnostics,
                                    &type, /* intantiateTemplate= */ true );
+   if (!decl) {
+      std::string strname{name};
+      std::string::size_type pos = strname.rfind("::(anonymous)");
+      if (pos != std::string::npos && strname.find("TString") == std::string::npos) {
+         const clang::Decl* anon = lh.findScope(strname.substr(0, pos),
+                                   gDebug > 5 ? cling::LookupHelper::WithDiagnostics
+                                   : cling::LookupHelper::NoDiagnostics,
+                                   &type, /* intantiateTemplate= */ true );
+         if (anon && llvm::dyn_cast<clang::RecordDecl>(anon)) {
+            const clang::RecordDecl* RD = llvm::dyn_cast<clang::RecordDecl>(anon);
+            for (auto f = RD->field_begin(); f != RD->field_end(); ++f) {
+            // if the field has a name, an unnamed union is no longer considered anonymous
+            // per Clang, as it does not put its names in the enclosing scope
+               auto* rt = f->getType()->getAs<RecordType>();
+               if (!rt) continue;
+               auto* RD = rt->getDecl();
+               if (RD->isAnonymousStructOrUnion() || (RD->isUnion() && RD->getNameAsString().empty())) {
+                   decl = RD;
+                   break;
+               }
+            }
+         }
+      }
+   }
    if (!decl) {
       std::string buf = TClassEdit::InsertStd(name);
       if (buf != name) {
