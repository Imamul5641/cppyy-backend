diff --git a/src/core/meta/src/TClass.cxx b/src/core/meta/src/TClass.cxx
index 29eb7f622f..72455671ad 100644
--- a/src/core/meta/src/TClass.cxx
+++ b/src/core/meta/src/TClass.cxx
@@ -2955,7 +2955,7 @@ TClass *TClass::GetClass(const char *name, Bool_t load, Bool_t silent)
    }
 
    std::string normalizedName;
-   Bool_t checkTable = kFALSE;
+   Bool_t checkTable = load;
 
    if (!cl) {
       {
diff --git a/src/core/metacling/src/TCling.cxx b/src/core/metacling/src/TCling.cxx
index 5894a0863b..354b1c4069 100644
--- a/src/core/metacling/src/TCling.cxx
+++ b/src/core/metacling/src/TCling.cxx
@@ -3660,7 +3736,7 @@ void TCling::SetClassInfo(TClass* cl, Bool_t reload)
    Bool_t zombieCandidate = kFALSE;
    if (
       info->IsValid() &&
-      !(info->Property() & (kIsClass | kIsStruct | kIsNamespace))
+      !(info->Property() & (kIsClass | kIsStruct | kIsUnion | kIsNamespace))
    ) {
       zombieCandidate = kTRUE;
    }
@@ -3806,8 +3882,8 @@ TCling::CheckClassInfo(const char *name, Bool_t autoload, Bool_t isClassOrNamesp
          SetClassAutoloading(storeAutoload);
          return kUnknown;
       }
-      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsNamespace :
-                                                     kIsClass | kIsStruct | kIsNamespace | kIsEnum | kIsUnion;
+      auto propertiesMask = isClassOrNamespaceOnly ? kIsClass | kIsStruct | kIsUnion | kIsNamespace :
+                                                     kIsClass | kIsStruct | kIsUnion | kIsNamespace | kIsEnum;

       if (tci.Property() & propertiesMask) {
          bool hasClassDefInline = false;
@@ -7567,6 +7599,13 @@ Bool_t TCling::ClassInfo_Contains(ClassInfo_t *info, DeclId_t declid) const
    else if (decl->getDeclContext()->isTransparentContext() &&
             decl->getDeclContext()->getParent()->Equals(ctxt))
       return kTRUE;
+   else {
+       const clang::RecordDecl* rec = llvm::dyn_cast<clang::RecordDecl>(decl->getDeclContext());
+       if (rec && rec->isAnonymousStructOrUnion() &&
+               decl->getDeclContext()->getParent()->Equals(ctxt))
+           return kTRUE;
+   }
+
    return kFALSE;
 }

diff --git a/src/core/metacling/src/TClingDataMemberInfo.cxx b/src/core/metacling/src/TClingDataMemberInfo.cxx
index 488f698305..3f6e4c8c5f 100644
--- a/src/core/metacling/src/TClingDataMemberInfo.cxx
+++ b/src/core/metacling/src/TClingDataMemberInfo.cxx
@@ -282,13 +283,26 @@ int TClingDataMemberInfo::InternalNext()
       clang::Decl::Kind DK = fIter->getKind();
       if (DK == clang::Decl::Enum) {
          // We have an enum, recurse into these.
-         // Note: For C++11 we will have to check for a transparent context.
+         // Note: For C++11 we will have to check for a transparent context (done from TListOfDataMembers::Load())
          fIterStack.push_back(fIter);
          cling::Interpreter::PushTransactionRAII RAII(fInterp);
          fIter = llvm::dyn_cast<clang::DeclContext>(*fIter)->decls_begin();
          increment = false; // avoid the next incrementation
          continue;
       }
+      if (DK == clang::Decl::Field) {
+         FieldDecl* ff = dyn_cast<FieldDecl>(*fIter);
+         if (ff->isAnonymousStructOrUnion()) {
+            fIterStack.push_back(fIter);
+            cling::Interpreter::PushTransactionRAII RAII(fInterp);
+            const auto* rec = ff->getType()->getAs<RecordType>()->getDecl();
+            if (rec) {
+               fIter = rec->decls_begin();
+               increment = false; // avoid the next incrementation
+               continue;
+            }
+         }
+      }
       if ((DK == clang::Decl::Field) || (DK == clang::Decl::EnumConstant) ||
           (DK == clang::Decl::Var)) {
          // Stop on class data members, enumerator values,
@@ -312,7 +326,20 @@ long TClingDataMemberInfo::Offset()
    if (const FieldDecl *FldD = dyn_cast<FieldDecl>(D)) {
       // The current member is a non-static data member.
       const clang::RecordDecl *RD = FldD->getParent();
+      if (RD->isAnonymousStructOrUnion()) {
+         // calculate the offset of the union in its parent (TODO: this seems silly)
+         const clang::RecordDecl* outer = llvm::dyn_cast<RecordDecl>(RD->getParent());
+         for (auto f = outer->field_begin(); f != outer->field_end(); ++f) {
+             auto* rt = f->getType()->getAs<RecordType>();
+             if (!rt) continue;
+             if (RD == rt->getDecl()) {
+                 FldD = *f;
+                 break;
+             }
+         }
+         RD = outer;
+      }
       const clang::ASTRecordLayout &Layout = C.getASTRecordLayout(RD);
       uint64_t bits = Layout.getFieldOffset(FldD->getFieldIndex());
       int64_t offset = C.toCharUnitsFromBits(bits).getQuantity();
       return static_cast<long>(offset);
